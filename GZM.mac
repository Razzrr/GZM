|**
    GZM.mac - GronnzMaster - The Ultimate EQ Boxing Macro
    Version 1.0.1 - December 2024

    A comprehensive boxing macro for EverQuest featuring:
    - DanNet/EQBC communication for multi-boxing
    - 10-state machine for robust operation
    - CH rotation for raid healing
    - Event-driven trigger system
    - OOG support and Nav integration
    - Timer throttling for performance

    REQUIRED PLUGINS:
    - MQ2DanNet (primary communication)
    - MQ2Nav (navigation/pathing)
    - MQ2MoveUtils (movement)
    - MQ2Exchange (item swapping)
    - MQ2Rez (resurrection handling)
    - MQ2Twist (bards only)

    OPTIONAL PLUGINS:
    - MQ2Cast (spell casting enhancement)
    - MQ2Melee (melee enhancement)
    - MQ2EQBC (backup communication)
    - MQ2AdvPath (path recording)
    - MQ2DPSAdv (DPS tracking)
    - MQ2SpawnMaster (spawn alerts)
    - MQ2Events (custom event handling)

    INCLUDE FILES:
    - ninjadvloot.inc (looting)
    - gzm_heals.inc (healing routines)
    - gzm_combat.inc (combat routines)
    - gzm_buffs.inc (buff routines)
    - gzm_pull.inc (pulling routines)
    - gzm_mez.inc (crowd control/mezzing)
    - gzm_slow.inc (slow priority system)
    - gzm_pet.inc (pet management/resummon)
    - gzm_chchain.inc (complete heal chain rotation)
    - gzm_charm.inc (charm pet system for ENC/NEC/DRU)
    - gzm_items.inc (item click rotation system)
    - gronnzmaster_custom.inc (user customization hooks)

    Usage: /mac gzm [role] [mainassist] [assistat]
    Example: /mac gzm assist TankName 95

    For detailed instructions: https://www.redguides.com/community/
**|
#warning
#turbo 120
#engine parser 2

| ============================================================================
| INCLUDE FILES
| ============================================================================
| Core State Management
#include_optional gzm_state.inc
#include_optional gzm_timers.inc
#include_optional gzm_death.inc
#include_optional gzm_zone.inc
#include_optional gzm_comm.inc
#include_optional gzm_lua.inc
#include_optional gzm_hotkeys.inc

| Standard Includes
#include ninjadvloot.inc
#include_optional gzm_heals.inc
#include_optional gzm_combat.inc
#include_optional gzm_buffs.inc
#include_optional gzm_pull.inc
#include_optional gzm_mez.inc
#include_optional gzm_slow.inc
#include_optional gzm_pet.inc
#include_optional gzm_chchain.inc
#include_optional gzm_charm.inc
#include_optional gzm_items.inc

| Utility Includes
#include_optional gzm_vendor.inc
#include_optional gzm_waypoint.inc
#include_optional gzm_food.inc
#include_optional gzm_loot.inc
#include_optional gzm_cursor.inc
#include_optional gzm_forage.inc
#include_optional gzm_group.inc
#include_optional gzm_aa.inc

| Custom User Hooks
#include_optional GronnzMaster_custom.inc

| ============================================================================
| PREPROCESSOR DEFINES - Debug Macros
| ============================================================================
| Version defined below in Sub Main as outer variable
#DEFINE GZMDEBUG "/if (${Debug}) /echo \at[GZM-DEBUG]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_BUFF "/if (${DebugBuffs}) /echo \aw[GZM-BUFF]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_CAST "/if (${DebugCast}) /echo \at[GZM-CAST]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_COMBAT "/if (${DebugCombat}) /echo \ar[GZM-COMBAT]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_HEAL "/if (${DebugHeal}) /echo \am[GZM-HEAL]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_MOVE "/if (${DebugMove}) /echo \ay[GZM-MOVE]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_MEZ "/if (${DebugMez}) /echo \ay[GZM-MEZ]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_PET "/if (${DebugPet}) /echo \ao[GZM-PET]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_PULL "/if (${DebugPull}) /echo \ay[GZM-PULL]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_NAV "/if (${DebugNav}) /echo \ap[GZM-NAV]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_OOG "/if (${DebugOOG}) /echo \ag[GZM-OOG]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_DANNET "/if (${DebugDanNet}) /echo \ab[GZM-DANNET]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE GZMDEBUG_ITEM "/if (${DebugItems}) /echo \ac[GZM-ITEM]\ag L:${Macro.CurLine} T:${Macro.RunTime} \aw"

| ============================================================================
| PREPROCESSOR DEFINES - Common Checks
| ============================================================================
#DEFINE BuffsNotAnItem ${Select[TRUE,${Bool[${Me.AltAbility[${SpellToCast}]}]},${Bool[${Me.CombatAbility[${SpellToCast}]}]},${Bool[${Me.Skill[${SpellToCast}]}]},${Bool[${Me.Book[${SpellToCast}]}]}]}
#DEFINE CANSTARTCOMBAT "(${MyTargetID} && (${Spawn[${MyTargetID}].Type.Equal[NPC]} || ${Spawn[${MyTargetID}].Type.Equal[PET]}) && ${Spawn[${MyTargetID}].PctHPs}<=${AssistAt} && (${Spawn[${MyTargetID}].Distance}<${MeleeDistance} || ${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius}))"
#DEFINE TANKMOBS "${If[${ReturnToCamp},${SpawnCount[npc loc ${CampXLoc} ${CampYLoc} radius ${CampRadius} targetable zradius ${MaxZRange}]},${SpawnCount[npc radius ${CampRadius} targetable zradius ${MaxZRange}]}]}"
#DEFINE WITHINCAMP "${If[${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]} < ${CampRadius},1,0]}"
#DEFINE PULLAGGROCHECK "${SpawnCount[xtarhater range ${PullRange} noalert 5]>0}"
#DEFINE XTCHECK "${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID}"

| Heading calculations
#DEFINE tHEAD "${Target.HeadingTo.DegreesCCW}"
#DEFINE tHEADING "${Target.Heading.DegreesCCW}"
#DEFINE mHEAD "${Me.Heading.DegreesCCW}"
#DEFINE FACING "${Range.Between[-35,35:${Math.Calc[(((mHEAD - tHEAD) + 540)%360)-180]}]}"

| ============================================================================
| CHAT CHANNELS
| ============================================================================
#chat tell
#chat group
#chat guild
#chat raid

| ============================================================================
| EVENT DEFINITIONS - General Events
| ============================================================================
#Event Camping           "#*#seconds to prepare your camp."
#Event Zoned             "LOADING, PLEASE WAIT#*#"
#Event Zoned             "You have entered#*#"
#Event Joined            "#1# has joined the group."
#Event LeftGroup         "#1# has left the group."
#Event Invited           "#*#To join the group, click on the 'FOLLOW' option#*#"
#Event GainSomething     "#*#You have gained|#1#|"
#Event TaskUpdate        "#*#Your task |#1#| has been updated#*#"
#Event Invised           "You Vanish #*#"
#Event TooSteep          "The ground here is too steep to camp"

| ============================================================================
| EVENT DEFINITIONS - Combat Events
| ============================================================================
#Event ImDead            "You died."
#Event ImDead            "You have been slain by#*#"
#Event ImDead            "#*#Returning to Bind Location#*#"
#Event GotHit            "#1# bashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# hits YOU for #*# points of damage.#*#"
#Event GotHit            "#1# crushes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# slashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# pierces YOU for #*# points of damage.#*#"
#Event GotHit            "#1# kicks YOU for #*# points of damage.#*#"
#Event GotHit            "#1# punches YOU for #*# points of damage.#*#"
#Event GotHit            "#1# bites YOU for #*# points of damage.#*#"
#Event GotHit            "#1# mauls YOU for #*# points of damage.#*#"
#Event GotHit            "#1# gores YOU for #*# points of damage.#*#"
#Event GotHit            "#1# smashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# rampages YOU for #*# points of damage.#*#"
#Event GotHit            "#1# tries to #*# YOU, but #*#"
#Event CantHit           "You can't hit them from here."
#Event CantSee           "You cannot see your target."
#Event TooClose          "Your target is too close to use a ranged weapon!"
#Event TooFar            "Your target is #*#, get closer!"
#Event Enraged           "#*#has become ENRAGED#*#"
#Event NotEnraged        "#*#is no longer enraged#*#"
#Event MezBroke          "#1# has been awakened by #2#."
#Event Banestrike        "Your Banestrike fails because you have not yet mastered slaying this race."

| ============================================================================
| EVENT DEFINITIONS - Casting Events
| ============================================================================
#Event CAST_BEGIN        "You begin casting #1#"
#Event CAST_BEGIN        "You begin singing #1#"
#Event CAST_FIZZLE       "Your spell fizzles#*#"
#Event CAST_FIZZLE       "You miss a note, bringing your song to a close#*#"
#Event CAST_INTERRUPTED  "Your spell is interrupted#*#"
#Event CAST_INTERRUPTED  "Your casting has been interrupted#*#"
#Event CAST_RESISTED     "Your target resisted the #1# spell#*#"
#Event CAST_RESISTED     "#*# resisted your #1#!"
#Event CAST_IMMUNE       "Your target is immune to #*#"
#Event CAST_IMMUNE       "Your target cannot be mesmerized#*#"
#Event CAST_IMMUNE       "Your target looks unaffected#*#"
#Event CAST_TAKEHOLD     "Your spell did not take hold#*#"
#Event CAST_TAKEHOLD     "Your spell would not have taken hold#*#"
#Event CAST_NOTARGET     "You must first select a target for this spell#*#"
#Event CAST_OUTOFMANA    "Insufficient Mana to cast this spell#*#"
#Event CAST_OUTOFRANGE   "Your target is out of range, get closer#*#"
#Event CAST_RECOVER      "You haven't recovered yet#*#"
#Event CAST_STUNNED      "You can't cast spells while stunned#*#"
#Event CAST_STANDING     "You must be standing to cast a spell#*#"
#Event CAST_OUTDOORS     "You can only cast this spell in the outdoors#*#"
#Event CAST_COMPONENTS   "You are missing some required components#*#"
#Event CAST_DISTRACTED   "You are too distracted to cast a spell now#*#"

| ============================================================================
| EVENT DEFINITIONS - Gift of Mana
| ============================================================================
#Event GoMOn             "#*#granted#*#gift of#*#mana#*#"
#Event GoMOn             "You feel strengthened by a gift of magic."
#Event GoMOff            "The gift of magic fades."
#Event GoMOff            "Your#*#gift of#*#mana fades."

| ============================================================================
| EVENT DEFINITIONS - Pet Events
| ============================================================================
#Event PTaunt            "#*#Taunting attackers as normal, Master.#*#"
#Event PetSusAdd         "#*# tells you, 'By your command, master.#*#"
#Event PetSusAdd         "#*#You cannot have more than one pet at a time.#*#"
#Event PetSusSub         "#*# tells you, 'I live again...'#*#"

| ============================================================================
| EVENT DEFINITIONS - Buff Events
| ============================================================================
#Event WornOff           "Your #1# spell has worn off of #2#."
#Event BuffsPlease       "#1# tells you, 'Buffs Please#*#"
#Event BuffsPlease       "#1# says, 'Buffs Please#*#"

| ============================================================================
| EVENT DEFINITIONS - Communication Events (EQBC/DanNet)
| ============================================================================
#Event EQBCIRC           "<#1#> #2#"
#Event FSEQBC            "#1# tells the fellowship, #2#"
#Event GUEQBC            "#1# tells the guild, #2#"
#Event YouGotTell        "#1# tells you, #2#"

| ============================================================================
| EVENT DEFINITIONS - Custom Command Events (KT Commands)
| ============================================================================
#Event KTDismount        "[MQ2] KTDismount#*#"
#Event KTDoorClick       "[MQ2] KTDoorClick #1#"
#Event KTHail            "[MQ2] KTHail #1#"
#Event KTInvite          "[MQ2] KTInvite #1#"
#Event KTSay             "[MQ2] KTSay #1#"
#Event KTTarget          "[MQ2] KTTarget #1#"

| ============================================================================
| EVENT DEFINITIONS - Customizable Triggers
| ============================================================================
#Event Trigger1          "#*#|${Trigger1Text}|#*#"
#Event Trigger2          "#*#|${Trigger2Text}|#*#"
#Event Trigger3          "#*#|${Trigger3Text}|#*#"
#Event Trigger4          "#*#|${Trigger4Text}|#*#"
#Event Trigger5          "#*#|${Trigger5Text}|#*#"

| ============================================================================
| EVENT DEFINITIONS - CH Rotation
| ============================================================================
#Event StartCHRot        "[MQ2] CCH Mode Activated -- #1# #2# #3# #4# #5# #6#"
#Event EndCHRot          "[MQ2] Ending Chain CH"
#Event CHOneBefore       "#*#|${CHOneBefore}${CHOneBefore}${CHOneBefore}|#*#"
#Event CHTwoBefore       "#*#|${CHTwoBefore}${CHTwoBefore}${CHTwoBefore}|#*#"
#Event CHGo              "#*#${Me.CleanName} GO#*#"
#Event CHTargetChange    "#*#CH ON #1#"
#Event CHTargetDead      "#*#${CHTargetName} has been slain#*#"

| ============================================================================
| EVENT DEFINITIONS - Tank Broadcast
| ============================================================================
#Event TankTarget        "<#1#>#*#TANKING-> #3# <- ID:#2#"
#Event TankTarget        "#*# #1# is TANKING-> #3# <- ID:#2#"

| ============================================================================
| EVENT DEFINITIONS - Loot Events
| ============================================================================
#Event BagsFull          "#*#There are no open slots for the held item in your inventory#*#"
#Event InventoryFull     "#*#Your inventory appears full!#*#"

| ============================================================================
| BIND COMMANDS - Core Commands
| ============================================================================
#bind GMHelp             /gmhelp
#bind GMStatus           /gmstatus
#bind GMReload           /gmreload
#bind GMDebug            /gmdebug
#bind GMSettings         /gmsettings
#bind GMCommand          /gm

| ============================================================================
| BIND COMMANDS - Combat Control
| ============================================================================
#bind BackOff            /backoff
#bind Burn               /burn
#bind PauseDPS           /pausedps
#bind ResumeDPS          /resumedps

| ============================================================================
| BIND COMMANDS - Movement/Camp
| ============================================================================
#bind MakeCampHere       /makecamphere
#bind ChaseMe            /chaseme
#bind StayHere           /stayhere
#bind NavTo              /navto

| ============================================================================
| BIND COMMANDS - Targeting
| ============================================================================
#bind SwitchMA           /switchma
#bind SwitchNow          /switchnow
#bind AddIgnore          /addignore
#bind AddPull            /addpull

| ============================================================================
| BIND COMMANDS - Buffs/Heals
| ============================================================================
#bind BuffGroup          /buffgroup
#bind GZMCast            /gzmcast

| ============================================================================
| BIND COMMANDS - Pulling
| ============================================================================
#bind SetPullArc         /setpullarc
#bind SetPullRanking     /setpullranking
#bind PullHold           /pullhold

| ============================================================================
| BIND COMMANDS - Variable Control
| ============================================================================
#bind ToggleVariable     /togglevariable
#bind ChangeVarInt       /changevarint
#bind IniWrite           /iniwrite

| ============================================================================
| BIND COMMANDS - Mez
| ============================================================================
#bind AddMezImmune       /addmezimmune

| ============================================================================
| BIND COMMANDS - OOG (Out of Group)
| ============================================================================
#bind OOGAssist          /oogassist
#bind OOGBuff            /oogbuff
#bind OOGHeal            /oogheal

| ============================================================================
| BIND COMMANDS - CH Chain
| ============================================================================
#bind StartCH            /startch
#bind StopCH             /stopch
#bind CHTarget           /chtarget
#bind CHDelay            /chdelay
#bind CHDuck             /chduck
#bind CHStatus           /chstatus

| ============================================================================
| BIND COMMANDS - Utility
| ============================================================================
#bind ZoneInfo           /zoneinfo
#bind Campfire           /campfire
#bind TrackMeDown        /trackmedown
#bind WriteSpells        /writespells
#bind MemSpells          /memspells

n| ============================================================================
| BIND COMMANDS - Lua Hybrid Mode
| ============================================================================
#bind LuaStatus          /gzmlua
#bind LuaStart           /gzmluastart
#bind LuaStop            /gzmlualstop

| ============================================================================
| BIND COMMANDS - Hotkeys and HUD
| ============================================================================
#bind GZMPause           /gzmpause
#bind GZMToggle          /gzmtoggle
#bind GZMAdjust          /gzmadjust
#bind GZMCamp            /gzmcamp
#bind GZMKeys            /gzmkeys
#bind GZMHUD             /gzmhud
| ============================================================================
| CONSTANTS
| ============================================================================
#define MAXBUFFS 40
#define MAXDEBUFFS 20
#define MAXDOTS 20
#define MAXNUKES 20
#define MAXHEALS 20
#define MAXCURES 10
#define MAXBURNS 30
#define MAXTRIGGERS 5
#define MAXOOGBUFFS 20
#define MAXPULLLOCS 5
#define MAXCONDITIONS 128
#define DEFAULT_CONDITION TRUE

| ============================================================================
| SUB MAIN - Entry Point
| ============================================================================
Sub Main
    /declare GVERSION string outer 1.0.0
    /declare i int local
    /declare StartupTime timer local

    /echo \ag============================================
    /echo \ag  GronnzMaster v${GVERSION} - Loading...
    /echo \ag============================================

    | -------------------------------------------------------------------------
    | Check for incompatible plugins
    | -------------------------------------------------------------------------
    /if (${Plugin[MQ2Bucles].Name.Length}) {
        /echo \arWarning: MQ2Bucles detected - unloading (incompatible)
        /squelch /plugin MQ2Bucles unload noauto
    }
    /if (${Plugin[MQ2XAssist].Name.Length}) {
        /echo \arWarning: MQ2XAssist detected - unloading (use Lua instead)
        /squelch /plugin MQ2XAssist unload noauto
    }

    | -------------------------------------------------------------------------
    | Check for required plugins
    | -------------------------------------------------------------------------
    /call CheckRequiredPlugins
    /if (!${Macro.Return}) /return

    | -------------------------------------------------------------------------
    | Setup Macro Name (needed by debug vars)
    | -------------------------------------------------------------------------
    /declare MacroName string outer GronnzMaster

    | -------------------------------------------------------------------------
    | Initialize Debug Variables (first, so we can debug everything else)
    | -------------------------------------------------------------------------
    /call DeclareDebugVars

    | -------------------------------------------------------------------------
    | Get Zone Name (handle commas/apostrophes)
    | -------------------------------------------------------------------------
    /declare ZoneName string outer ${Zone}
    /if (${ZoneName.Find[,]} || ${ZoneName.Find[']}) {
        GZMDEBUG Zone name has special chars, using short name
        /varset ZoneName ${Zone.ShortName}
    }
    /if (${Me.InInstance}) {
        /varset ZoneName ${ZoneName}_I
    }

    | -------------------------------------------------------------------------
    | Setup INI File Names
    | -------------------------------------------------------------------------
    /declare MacroVer string outer ${GVERSION}
    /declare IniFileName string outer ${MacroName}_${EverQuest.Server}_${Me.CleanName}.ini
    /declare BuffFileName string outer ${MacroName}_Buffs.ini
    /declare ConditionsFileName string outer ${MacroName}_${Me.CleanName}_Conditions.ini

    /echo \ayUsing INI: ${IniFileName}

    | -------------------------------------------------------------------------
    | Parse Command Line Parameters
    | -------------------------------------------------------------------------
    /call ParseCommandLine

    | -------------------------------------------------------------------------
    | Declare All Outer Variables
    | -------------------------------------------------------------------------
    /call DeclareOuterVars
    /if (${Defined[CustomDeclareVars]}) /call CustomDeclareVars

    | -------------------------------------------------------------------------
    | Load INI Settings
    | -------------------------------------------------------------------------
    /call LoadAllSettings
    /if (${Defined[CustomInit]}) /call CustomInit

    | -------------------------------------------------------------------------
    | Setup Communication (DanNet primary, EQBC fallback)
    | -------------------------------------------------------------------------
    /call SetupCommunication
    /call SetupDanNetObservers

    | -------------------------------------------------------------------------
    | Setup Looting
    | -------------------------------------------------------------------------
    /if (${LootOn}) {
        /call SetupAdvLootVars
    }

    | -------------------------------------------------------------------------
    | Setup Aliases (if version changed)
    | -------------------------------------------------------------------------
    /call SetupAliases

    | -------------------------------------------------------------------------
    | Initialize State Management System
    | -------------------------------------------------------------------------
    /if (${Defined[InitStateVars]}) {
        /call InitStateVars
        /echo \ag[GZM] State management system initialized
    }
    /if (${Defined[InitTimerVars]}) {
        /call InitTimerVars
        /echo \ag[GZM] Timer throttle system initialized
    }
    /if (${Defined[InitDeathVars]}) {
        /call InitDeathVars
        /echo \ag[GZM] Death handling system initialized
    }
    /if (${Defined[InitZoneVars]}) {
        /call InitZoneVars
        /echo \ag[GZM] Zone handling system initialized
    }

    | -------------------------------------------------------------------------
    | Initialize Utility Systems
    | -------------------------------------------------------------------------
    /if (${Defined[InitCursorVars]}) {
        /call InitCursorVars
        /echo \ag[GZM] Cursor/StuckGem system initialized
    }
    /if (${Defined[InitForageVars]}) {
        /call InitForageVars
        /echo \ag[GZM] Forage system initialized
    }
    /if (${Defined[InitGroupVars]}) {
        /call InitGroupVars
        /echo \ag[GZM] Group management system initialized
    }
    /if (${Defined[InitAAVars]}) {
        /call InitAAVars
        /call AAInit
        /echo \ag[GZM] AA purchasing system initialized
    }
    /if (${Defined[InitCombatHooks]}) {
        /call InitCombatHooks
        /echo \ag[GZM] Combat hooks system initialized
    }

    | Load zone-specific immunities
    /if (${Defined[LoadImmunes]}) {
        /call LoadImmunes
    }
    
    | Initialize Lua hybrid mode (if available)
    /if (${Defined[InitLuaIntegration]}) {
        /call InitLuaIntegration
    }

    | Initialize Hotkeys and HUD (if available)
    /if (${Defined[InitHotkeys]}) {
        /call InitHotkeys
        /call LoadGZMHud
    }

    | -------------------------------------------------------------------------
    | Run OnStart Commands
    | -------------------------------------------------------------------------
    /call RunOnStart
    /call AutoLaunchUI

    | -------------------------------------------------------------------------
    | Startup Complete
    | -------------------------------------------------------------------------
    /echo \ag============================================
    /echo \ag  GronnzMaster v${GVERSION} - Ready!
    /echo \ag  Role: ${Role} | MA: ${MainAssist} | AssistAt: ${AssistAt}%
    /echo \ag============================================

    | -------------------------------------------------------------------------
    | MAIN LOOP
    | -------------------------------------------------------------------------
    :MainLoop
    /if (!${MacroRunning}) /return

    /doevents

    | -------------------------------------------------------------------------
    | State Machine Gate - Check if automation should run
    | -------------------------------------------------------------------------
    /if (${Defined[CanAutomate]}) {
        /call CanAutomate
        /if (!${Macro.Return}) {
            /delay 5
            /goto :MainLoop
        }
    }

    | Check if paused (legacy support)
    /if (${Paused}) {
        /delay 5
        /goto :MainLoop
    }

    | -------------------------------------------------------------------------
    | Zone Change Detection
    | -------------------------------------------------------------------------
    /if (${Defined[CheckZoneChange]}) {
        /call CheckZoneChange
        /if (${Macro.Return}) {
            /call HandleZoning
            /goto :MainLoop
        }
    } else /if (${JustZoned}) {
        /call HandleZoning
        /goto :MainLoop
    }

    | -------------------------------------------------------------------------
    | Death Detection
    | -------------------------------------------------------------------------
    /if (${Me.Dead}) {
        /call HandleDeath
        /goto :MainLoop
    }

    | -------------------------------------------------------------------------
    | Priority 1: Emergency Checks (health, aggro, FD)
    | -------------------------------------------------------------------------
    /call CheckEmergency

    | Check if feigned - wait before doing anything
    /if (${FDOn}) /call FeignAggroCheck
    /if (${Me.Feigning}) /goto :MainLoop

    | Check MA status (off-tank failover)
    /if (${OffTankOn}) /call CheckMAStatus

    | -------------------------------------------------------------------------
    | Priority 2: Healing (if healer role) - NO THROTTLE (critical)
    | -------------------------------------------------------------------------
    /if (${HealsOn} && ${Select[${MyClass},CLR,DRU,SHM,PAL,RNG,BST,NEC]}) {
        /call CheckHealing
    }

    | -------------------------------------------------------------------------
    | Priority 3: Cures (if cure enabled) - NO THROTTLE (critical)
    | -------------------------------------------------------------------------
    /if (${CuresOn} && ${Select[${MyClass},CLR,DRU,SHM,PAL,RNG]}) {
        /call CheckCures
    }

    | -------------------------------------------------------------------------
    | Priority 4: Combat - THROTTLED (0.5s)
    | -------------------------------------------------------------------------
    /if (${Defined[CanCheckCombat]}) {
        /call CanCheckCombat
        /if (${Macro.Return}) {
            /call MobRadar los ${MeleeDistance} MainLoop
            /call CheckForCombat
        }
    } else {
        /call MobRadar los ${MeleeDistance} MainLoop
        /call CheckForCombat
    }

    | AE Check during combat
    /if (${AECheckOn} && ${InCombat}) /call AECheck

    | Check stuck gems (use enhanced version if available)
    /if (${Me.Casting.ID}) {
        /if (${Defined[StuckGemsCheck]}) {
            /call StuckGemsCheck
        } else /if (${CheckStuckGem}) {
            /call CheckStuckGems
        }
    }

    | -------------------------------------------------------------------------
    | Priority 5: Bard stuff (twist management)
    | -------------------------------------------------------------------------
    /if (${IAmABard}) /call DoBardStuff

    | -------------------------------------------------------------------------
    | Priority 6: Buffs (out of combat) - THROTTLED (3s)
    | -------------------------------------------------------------------------
    /if (!${InCombat} && ${BuffsOn}) {
        /if (${Defined[CanCheckBuffs]}) {
            /call CanCheckBuffs
            /if (${Macro.Return}) /call CheckBuffs
        } else {
            /call CheckBuffs
        }
    }

    | -------------------------------------------------------------------------
    | Priority 7: Pulling (if puller role) - THROTTLED (2s)
    | -------------------------------------------------------------------------
    /if (${Select[${Role},Puller,PullerTank,PullerPetTank,Hunter,HunterTank,HunterPetTank]}) {
        /if (${Defined[CanCheckPull]}) {
            /call CanCheckPull
            /if (${Macro.Return}) /call CheckPulling
        } else {
            /call CheckPulling
        }
    }

    | Hunter mode - find mobs to hunt
    /if (${HunterMode} && ${Select[${Role},Hunter,HunterTank,HunterPetTank]}) {
        /call HunterFindMob
    }

    | -------------------------------------------------------------------------
    | Priority 8: Movement (chase/camp)
    | -------------------------------------------------------------------------
    /call CheckMovement

    | Campfire return
    /if (${ClickBacktoCamp}) /call CampfireBack

    | Corpse recovery
    /if (${CorpseRecoveryOn}) /call RecoverCorpses

    | -------------------------------------------------------------------------
    | Priority 9: Idle Tasks (med, forage, etc) - THROTTLED (5s)
    | -------------------------------------------------------------------------
    /if (${Defined[CanCheckSitMed]}) {
        /call CanCheckSitMed
        /if (${Macro.Return}) /call CheckIdleTasks
    } else {
        /call CheckIdleTasks
    }

    | -------------------------------------------------------------------------
    | Priority 10: Mercenary Control
    | -------------------------------------------------------------------------
    /if (${MercOn}) /call MercsDoWhat

    | -------------------------------------------------------------------------
    | Priority 11: OOG Support
    | -------------------------------------------------------------------------
    /if (${OOGOn}) {
        /call CheckOOG
    }

    | -------------------------------------------------------------------------
    | Priority 12: Group Watch
    | -------------------------------------------------------------------------
    /if (${GroupWatchOn}) /call GroupWatch

    | -------------------------------------------------------------------------
    | Priority 13: AFK Tools
    | -------------------------------------------------------------------------
    /if (${AFKToolsOn}) /call AFKTools

    | -------------------------------------------------------------------------
    | Priority 14: Pet Toys
    | -------------------------------------------------------------------------
    /if (${PetToysOn} && ${Me.Pet.ID}) /call CheckPetToys

    | Loop delay
    /delay 1

    /goto :MainLoop
/return

| ============================================================================
| SUB: Check Required Plugins
| ============================================================================
Sub CheckRequiredPlugins
    /declare PluginsMissing int local 0

    | Required plugins
    /if (!${Plugin[MQ2DanNet].Name.Length}) {
        /echo \arERROR: MQ2DanNet is REQUIRED - Loading...
        /squelch /plugin MQ2DanNet noauto
        /delay 10
        /if (!${Plugin[MQ2DanNet].Name.Length}) {
            /echo \arFATAL: Could not load MQ2DanNet!
            /varset PluginsMissing 1
        }
    }

    /if (!${Plugin[MQ2Nav].Name.Length}) {
        /echo \ayWarning: MQ2Nav not loaded - Navigation features disabled
        /echo \ayLoading MQ2Nav...
        /squelch /plugin MQ2Nav noauto
    }

    /if (!${Plugin[MQ2MoveUtils].Name.Length}) {
        /echo \arERROR: MQ2MoveUtils is REQUIRED - Loading...
        /squelch /plugin MQ2MoveUtils noauto
        /delay 10
        /if (!${Plugin[MQ2MoveUtils].Name.Length}) {
            /echo \arFATAL: Could not load MQ2MoveUtils!
            /varset PluginsMissing 1
        }
    }

    /if (!${Plugin[MQ2Exchange].Name.Length}) {
        /echo \ayWarning: MQ2Exchange not loaded - Loading...
        /squelch /plugin MQ2Exchange noauto
    }

    /if (!${Plugin[MQ2Rez].Name.Length}) {
        /echo \ayWarning: MQ2Rez not loaded - Loading...
        /squelch /plugin MQ2Rez noauto
    }

    | Optional plugins - just note if missing
    /if (!${Plugin[MQ2Cast].Name.Length}) {
        /echo \awNote: MQ2Cast not loaded (optional)
    }
    /if (!${Plugin[MQ2Melee].Name.Length}) {
        /echo \awNote: MQ2Melee not loaded (optional)
    }
    /if (!${Plugin[MQ2Events].Name.Length}) {
        /echo \awNote: MQ2Events not loaded (optional - custom events disabled)
    }
    /if (!${Plugin[MQ2EQBC].Name.Length}) {
        /echo \awNote: MQ2EQBC not loaded (DanNet is primary)
    }
    /if (!${Plugin[MQ2SpawnMaster].Name.Length}) {
        /echo \awNote: MQ2SpawnMaster not loaded (optional)
    }

    | Check if bard needs twist
    /if (${Me.Class.ShortName.Equal[BRD]} && !${Plugin[MQ2Twist].Name.Length}) {
        /echo \arERROR: Bards REQUIRE MQ2Twist - Loading...
        /squelch /plugin MQ2Twist noauto
        /delay 10
        /if (!${Plugin[MQ2Twist].Name.Length}) {
            /echo \arFATAL: Could not load MQ2Twist!
            /varset PluginsMissing 1
        }
    }

    /if (${PluginsMissing}) {
        /echo \arFATAL: Required plugins missing. Ending macro.
        /return 0
    }

/return 1

| ============================================================================
| SUB: Declare Debug Variables
| ============================================================================
Sub DeclareDebugVars
    /declare Debug int outer 0
    /declare DebugBuffs int outer 0
    /declare DebugCast int outer 0
    /declare DebugCombat int outer 0
    /declare DebugHeal int outer 0
    /declare DebugMove int outer 0
    /declare DebugMez int outer 0
    /declare DebugPet int outer 0
    /declare DebugPull int outer 0
    /declare DebugNav int outer 0
    /declare DebugOOG int outer 0
    /declare DebugDanNet int outer 0
    /declare DebugItems int outer 0
    /declare DebugAll int outer 0
    /declare WriteDebug string outer N
    /declare WriteDebugINI string outer "${MacroName}_Debug_${Me.CleanName}.ini"
/return

| ============================================================================
| SUB: Parse Command Line
| ============================================================================
Sub ParseCommandLine
    /declare NumParams int local ${Macro.Params}
    /declare i int local

    | Default values
    /declare Role string outer Assist
    /declare MainAssist string outer ${Me.CleanName}
    /declare AssistAt int outer 98

    /if (${NumParams} >= 1 && ${Defined[Param0]}) {
        /varset Role ${Param0}
        /echo \ayCmdLine: Role = ${Role}
    }
    /if (${NumParams} >= 2 && ${Defined[Param1]}) {
        /varset MainAssist ${Param1}
        /echo \ayCmdLine: MainAssist = ${MainAssist}
    }
    /if (${NumParams} >= 3 && ${Defined[Param2]}) {
        /varset AssistAt ${Param2}
        /echo \ayCmdLine: AssistAt = ${AssistAt}
    }
/return

| ============================================================================
| SUB: Declare Outer Variables
| ============================================================================
Sub DeclareOuterVars
    /declare i int local

    | -------------------------------------------------------------------------
    | State Variables
    | -------------------------------------------------------------------------
    /declare Paused int outer 0
    /declare InCombat int outer 0
    /declare JustZoned int outer 0
    /declare MacroRunning int outer 1
    /declare CombatStart int outer 0
    /declare Pulling int outer 0
    /declare BackOffFlag timer outer 0
    /declare DanNetObserversSetup int outer 0

    | -------------------------------------------------------------------------
    | Camp Variables
    | -------------------------------------------------------------------------
    /declare CampXLoc float outer ${Me.X}
    /declare CampYLoc float outer ${Me.Y}
    /declare CampZLoc float outer ${Me.Z}
    /declare CampRadius int outer 50
    /declare CampRadiusExceed int outer 400
    /declare ReturnToCamp int outer 0
    /declare MaxZRange int outer 50

    | -------------------------------------------------------------------------
    | Chase Variables
    | -------------------------------------------------------------------------
    /declare ChaseAssist int outer 0
    /declare ChaseDistance int outer 30
    /declare WhoToChase string outer ${MainAssist}

    | -------------------------------------------------------------------------
    | Targeting/Assist Variables
    | -------------------------------------------------------------------------
    /declare MyTargetID int outer 0
    /declare MainAssistID int outer 0
    /declare LastTargetID int outer 0
    /declare TargetSwitchingOn int outer 1
    /declare AssistOn int outer 1
    /declare IAmMA int outer 0

    | -------------------------------------------------------------------------
    | Combat Variables
    | -------------------------------------------------------------------------
    /declare MeleeOn int outer 1
    /declare MeleeDistance int outer 25
    /declare RangedOn int outer 0
    /declare DPSOn int outer 1
    /declare StickDistance int outer 15
    /declare StickPoint string outer behind
    /declare StickMod string outer moveback
    /declare AutoFireOn int outer 0
    /declare Enraged int outer 0

    | DPS Spells
    /declare NukeOn int outer 1
    /declare DoTOn int outer 1
    /declare NukeManaPct int outer 40
    /declare DoTManaPct int outer 50
    /declare StopDPSPct int outer 10
    /declare Nuke1 string outer
    /declare Nuke2 string outer
    /declare Nuke3 string outer
    /declare DoT1 string outer
    /declare DoT2 string outer
    /declare DoT3 string outer
    /declare DoT4 string outer
    /declare DoT5 string outer

    | Debuff Spells
    /declare DebuffOn int outer 1
    /declare Debuff1 string outer
    /declare Debuff1Type string outer
    /declare Debuff2 string outer
    /declare Debuff2Type string outer
    /declare Debuff3 string outer
    /declare Debuff3Type string outer
    /declare SlowSpell string outer

    | Burn Abilities
    /declare Burn1 string outer
    /declare Burn1Type string outer
    /declare Burn2 string outer
    /declare Burn2Type string outer
    /declare Burn3 string outer
    /declare Burn3Type string outer

    | Pull Spell
    /declare PullSpell string outer

    | -------------------------------------------------------------------------
    | Healing Variables
    | -------------------------------------------------------------------------
    /declare HealsOn int outer 1
    /declare HealPct int outer 70
    /declare HealGroupPct int outer 80
    /declare HealRaidPct int outer 60
    /declare EmergencyHealPct int outer 35
    /declare OOGHealPct int outer 60

    | Heal Spells
    /declare MainHeal string outer
    /declare QuickHeal string outer
    /declare EmergencyHeal string outer
    /declare HoT1 string outer
    /declare HoT1Pct int outer 90
    /declare GroupHeal string outer
    /declare GroupHealPct int outer 70

    | -------------------------------------------------------------------------
    | Buff Variables
    | -------------------------------------------------------------------------
    /declare BuffsOn int outer 1
    /declare RebuffOn int outer 1
    /declare BuffCheckTimer timer outer 0
    /declare BuffTimer timer outer 0

    | Self Buffs (up to 5)
    /declare SelfBuff1 string outer
    /declare SelfBuff2 string outer
    /declare SelfBuff3 string outer
    /declare SelfBuff4 string outer
    /declare SelfBuff5 string outer

    | Group Buffs (up to 5)
    /declare GroupBuff1 string outer
    /declare GroupBuff1Class string outer All
    /declare GroupBuff2 string outer
    /declare GroupBuff2Class string outer All
    /declare GroupBuff3 string outer
    /declare GroupBuff3Class string outer All
    /declare GroupBuff4 string outer
    /declare GroupBuff4Class string outer All
    /declare GroupBuff5 string outer
    /declare GroupBuff5Class string outer All

    | Pet Buffs (up to 3)
    /declare PetBuff1 string outer
    /declare PetBuff2 string outer
    /declare PetBuff3 string outer

    | OOG Buffs - Buffs for DanNet characters not in group (up to 5)
    /declare OOGBuff1 string outer
    /declare OOGBuff1Class string outer All
    /declare OOGBuff2 string outer
    /declare OOGBuff2Class string outer All
    /declare OOGBuff3 string outer
    /declare OOGBuff3Class string outer All
    /declare OOGBuff4 string outer
    /declare OOGBuff4Class string outer All
    /declare OOGBuff5 string outer
    /declare OOGBuff5Class string outer All

    | -------------------------------------------------------------------------
    | Pull Variables
    | -------------------------------------------------------------------------
    /declare PullOn int outer 0
    /declare PullRange int outer 200
    /declare PullZRange int outer 50
    /declare PullHold int outer 0
    /declare PullDelay int outer 10
    /declare ChainPull int outer 0
    /declare ChainPullHP int outer 20
    /declare PullArc int outer 360
    /declare PullRanking int outer 0
    /declare PullNavOn int outer 1
    /declare PullList string outer
    /declare IgnoreList string outer
    /declare PullLocsOn int outer 0
    /declare PullLocCount int outer 0
    /declare PullLocY[${MAXPULLLOCS}] float outer 0
    /declare PullLocX[${MAXPULLLOCS}] float outer 0
    /declare PullLocRadius[${MAXPULLLOCS}] float outer 0

    | -------------------------------------------------------------------------
    | Pet Variables
    | -------------------------------------------------------------------------
    /declare PetOn int outer 1
    /declare PetHold int outer 0
    /declare PetAssist int outer 1
    /declare PetTaunt int outer 0

    | -------------------------------------------------------------------------
    | Mez Variables
    | -------------------------------------------------------------------------
    /declare MezOn int outer 0
    /declare MezRadius int outer 50
    /declare MezMinLevel int outer 1
    /declare MezMaxLevel int outer 200

    | -------------------------------------------------------------------------
    | Mez Tracking Variables (for GUI display)
    | -------------------------------------------------------------------------
    /declare MezTargetCount int outer 0
    /declare MezTarget1ID int outer 0
    /declare MezTarget1Name string outer
    /declare MezTarget1Timer timer outer 0
    /declare MezTarget2ID int outer 0
    /declare MezTarget2Name string outer
    /declare MezTarget2Timer timer outer 0
    /declare MezTarget3ID int outer 0
    /declare MezTarget3Name string outer
    /declare MezTarget3Timer timer outer 0
    /declare MezTarget4ID int outer 0
    /declare MezTarget4Name string outer
    /declare MezTarget4Timer timer outer 0
    /declare MezTarget5ID int outer 0
    /declare MezTarget5Name string outer
    /declare MezTarget5Timer timer outer 0

    | -------------------------------------------------------------------------
    | Slow Variables
    | -------------------------------------------------------------------------
    /declare SlowOn int outer 0

    | -------------------------------------------------------------------------
    | Charm Variables
    | -------------------------------------------------------------------------
    /declare CharmOn int outer 0

    | -------------------------------------------------------------------------
    | Item Click Variables
    | -------------------------------------------------------------------------
    /declare ItemClicksOn int outer 1

    | -------------------------------------------------------------------------
    | Loot Variables
    | -------------------------------------------------------------------------
    /declare LootOn int outer 1
    /declare LootRadius int outer 100
    /declare LootCombat int outer 0

    | -------------------------------------------------------------------------
    | Communication Variables
    | -------------------------------------------------------------------------
    /declare UseDanNet int outer 1
    /declare UseEQBC int outer 0
    /declare BroadcastChannel string outer say
    /declare BroadcastBuffs int outer 1
    /declare BroadcastHeals int outer 0
    /declare ConditionsOn int outer 0
    /declare AutoLaunchGUI int outer 0
    /declare AutoLaunchHUD int outer 0

    | -------------------------------------------------------------------------
    | Spell Memorization Variables
    | MiscGem is the primary gem for temporary spell memorization
    | -------------------------------------------------------------------------
    /declare MiscGem int outer 8
    /declare MiscGemLW int outer 7
    /declare DontMoveMe int outer 0
    /declare ReMemMiscSpell string outer
    /declare ReMemWaitShort string outer null
    /declare ReMemWaitLong string outer null

    | -------------------------------------------------------------------------
    | OOG Variables
    | -------------------------------------------------------------------------
    /declare OOGOn int outer 0
    /declare OOGHealOn int outer 0
    /declare OOGBuffOn int outer 0
    /declare OOGAssistOn int outer 0
    /declare OOGRange int outer 200

    | -------------------------------------------------------------------------
    | DanNet Buffing Variables
    | -------------------------------------------------------------------------
    | DanNetBuffOn - applies GroupBuffs to ALL DanNet peers (not just group)
    /declare DanNetBuffOn int outer 1

    | -------------------------------------------------------------------------
    | Nav Variables
    | -------------------------------------------------------------------------
    /declare UseNav int outer 1
    /declare NavTimeout int outer 30
    /declare NavStuckDist float outer 5

    | -------------------------------------------------------------------------
    | Burn Variables
    | -------------------------------------------------------------------------
    /declare BurnNow int outer 0
    /declare BurnAllNamed int outer 0
    /declare BurnPct int outer 95

    | -------------------------------------------------------------------------
    | Class Specific
    | -------------------------------------------------------------------------
    /declare MyClass string outer ${Me.Class.ShortName}

    | -------------------------------------------------------------------------
    | Class Category Flags - for special handling of hybrid classes
    | -------------------------------------------------------------------------
    | Lifetap Classes: Heal themselves through offensive spells (DPS = self heal)
    | - Shadow Knight, Necromancer
    | - Should NOT use traditional healing system
    | - Their "heals" come from their DPS rotation
    /declare IsLifetapClass int outer ${Select[${Me.Class.ShortName},SHD,NEC]}

    | Hybrid Tank/Healer: Can tank AND heal, but not simultaneously
    | - Paladin
    | - When Role=Tank: Focus on tanking, don't switch targets to heal others
    | - When Role=Healer: Normal healer behavior, spot heal the group
    /declare IsHybridTankHealer int outer ${Select[${Me.Class.ShortName},PAL]}

    | Pure Tanks: Can only tank, no healing capability
    | - Warrior
    | - Never try to heal, focus 100% on aggro and mitigation
    /declare IsPureTank int outer ${Select[${Me.Class.ShortName},WAR]}

    | Primary Healers: Main job is healing, may have other abilities
    | - Cleric, Druid, Shaman
    | - Cleric: Pure healer, best heals, rez
    | - Druid: Healer + ports + snare + nukes
    | - Shaman: Healer + slows + buffs + dots
    /declare IsPrimaryHealer int outer ${Select[${Me.Class.ShortName},CLR,DRU,SHM]}

    | Tank Classes: All classes that can/should tank
    | - Warrior, Shadow Knight, Paladin
    /declare IsTankClass int outer ${Select[${Me.Class.ShortName},WAR,SHD,PAL]}

    | -------------------------------------------------------------------------
    | Statistics Counters (for GUI display)
    | -------------------------------------------------------------------------
    /declare HealsCast int outer 0
    /declare NukesCast int outer 0
    /declare DoTsCast int outer 0
    /declare MezzesCast int outer 0
    /declare SlowsCast int outer 0
    /declare PullsDone int outer 0
    /declare BuffsCast int outer 0
    /declare RezzesCast int outer 0
    /declare CuresCast int outer 0

    | -------------------------------------------------------------------------
    | Timers
    | -------------------------------------------------------------------------
    /declare GlobalTimer timer outer 0
    /declare CombatTimer timer outer 0
    /declare PullTimer timer outer 0
    /declare HealTimer timer outer 0
    /declare GoMTimer timer outer 0
    /declare SpamTimer1 timer outer 0
    /declare SpamTimer2 timer outer 0
    /declare FizzleTimer timer outer 0
    /declare LastCastSuccess int outer 1

    | -------------------------------------------------------------------------
    | Trigger Text Variables - check if exists first
    | -------------------------------------------------------------------------
    /if (!${Defined[Trigger1Text]}) /declare Trigger1Text string outer TRIGGER1
    /if (!${Defined[Trigger2Text]}) /declare Trigger2Text string outer TRIGGER2
    /if (!${Defined[Trigger3Text]}) /declare Trigger3Text string outer TRIGGER3
    /if (!${Defined[Trigger4Text]}) /declare Trigger4Text string outer TRIGGER4
    /if (!${Defined[Trigger5Text]}) /declare Trigger5Text string outer TRIGGER5

    | -------------------------------------------------------------------------
    | CH Rotation Variables - check if exists first
    | -------------------------------------------------------------------------
    /if (!${Defined[CHRotOn]}) /declare CHRotOn int outer 0
    /if (!${Defined[CHOneBefore]}) /declare CHOneBefore string outer
    /if (!${Defined[CHTwoBefore]}) /declare CHTwoBefore string outer
    /if (!${Defined[CHTarget]}) /declare CHTarget int outer 0
    /if (!${Defined[CHSpell]}) /declare CHSpell string outer

    | -------------------------------------------------------------------------
    | CH Chain Extended Variables (for GUI display)
    | -------------------------------------------------------------------------
    /declare CHPosition int outer 0
    /declare CHNextHealer string outer
    /declare CHPrevHealer string outer
    /declare CHChainMembers string outer
    /declare CHCastingNow int outer 0
    /declare CHTimeToCast timer outer 0

    | -------------------------------------------------------------------------
    | Misc Variables
    | -------------------------------------------------------------------------
    /declare MedOn int outer 1
    /declare MedStart int outer 80
    /declare MedStop int outer 95
    /declare SitToMed int outer 1
    /declare ForageOn int outer 0
    /declare AutoRezOn int outer 1
    /declare CorpseRunNav int outer 1

    | -------------------------------------------------------------------------
    | Cure Variables
    | -------------------------------------------------------------------------
    /declare CuresOn int outer 1
    /declare CurePoison int outer 1
    /declare CureDisease int outer 1
    /declare CureCurse int outer 1
    /declare CureCorrupt int outer 0
    /declare CureSpell1 string outer
    /declare CureSpell1Type string outer
    /declare CureSpell2 string outer
    /declare CureSpell2Type string outer
    /declare CureSpell3 string outer
    /declare CureSpell3Type string outer
    /declare CureTimer timer outer 0

    | -------------------------------------------------------------------------
    | Bard Variables
    | -------------------------------------------------------------------------
    /declare IAmABard int outer 0
    /declare MeleeTwistOn int outer 0
    /declare MeleeTwist string outer
    /declare CombatMelody string outer
    /declare RestMelody string outer
    /declare PullMelody string outer
    /declare TwistTimer timer outer 0
    /declare DPSTwisting int outer 0

    | -------------------------------------------------------------------------
    | Feign Death Variables
    | -------------------------------------------------------------------------
    /declare FDOn int outer 0
    /declare FDHPPct int outer 20
    /declare FDSpell string outer
    /declare FDSplitPull int outer 0
    /declare FDAggroCheck int outer 1
    /declare FDAggroDelay int outer 50
    /declare IAmFeigned int outer 0

    | -------------------------------------------------------------------------
    | Mercenary Variables
    | -------------------------------------------------------------------------
    /declare MercOn int outer 0
    /declare MercAssist int outer 1
    /declare MercStance string outer balanced
    /declare MercSuspendOn int outer 0

    | -------------------------------------------------------------------------
    | Off-Tank/Failover Variables
    | -------------------------------------------------------------------------
    /declare OffTankOn int outer 0
    /declare OrigMainAssist string outer
    /declare MADownTimer timer outer 0
    /declare MAFailoverDelay int outer 30

    | -------------------------------------------------------------------------
    | AE Check Variables
    | -------------------------------------------------------------------------
    /declare AECheckOn int outer 0
    /declare AEFleeRange int outer 50
    /declare AEFleeHP int outer 50
    /declare AEMobCount int outer 3
    /declare AERunToWP string outer
    /declare DodgeAE int outer 0

    | -------------------------------------------------------------------------
    | Corpse Recovery Variables
    | -------------------------------------------------------------------------
    /declare CorpseRecoveryOn int outer 0
    /declare DragCorpse int outer 0
    /declare CorpseSummonOn int outer 0
    /declare CorpseSummonSpell string outer

    | -------------------------------------------------------------------------
    | Campfire Variables
    | -------------------------------------------------------------------------
    /declare CampfireOn int outer 0
    /declare ClickBacktoCamp int outer 0
    /declare FellowshipRecallOn int outer 0

    | -------------------------------------------------------------------------
    | Pet Toys/Begging Variables
    | -------------------------------------------------------------------------
    /declare PetToysOn int outer 0
    /declare PetBegActive int outer 0
    /declare PetToysGiven int outer 0

    | -------------------------------------------------------------------------
    | AFK Tools Variables
    | -------------------------------------------------------------------------
    /declare AFKToolsOn int outer 0
    /declare AFKReply string outer I am AFK using GronnzMaster.
    /declare AFKAutoReply int outer 0

    | -------------------------------------------------------------------------
    | Group Watch Variables
    | -------------------------------------------------------------------------
    /declare GroupWatchOn int outer 0
    /declare GroupWatchHealPct int outer 50
    /declare GroupWatchAlertDead int outer 1

    | -------------------------------------------------------------------------
    | Hunter Mode Variables
    | -------------------------------------------------------------------------
    /declare HunterMode int outer 0
    /declare HunterMinMobs int outer 0
    /declare HunterMaxMobs int outer 10
    /declare HunterRadius int outer 500
    /declare HunterZRadius int outer 100
    /declare HunterNavPause int outer 0

    | -------------------------------------------------------------------------
    | XTarget Variables
    | -------------------------------------------------------------------------
    /declare XTSlot int outer 0
    /declare XTAggroCount int outer 0
    /declare AggroTargetID int outer 0
    /declare MobCount int outer 0

    | -------------------------------------------------------------------------
    | Stuck Gem Check Variables
    | -------------------------------------------------------------------------
    /declare CheckStuckGem int outer 1
    /declare StuckGemTimer timer outer 0
    /declare LastCastTime int outer 0

    | -------------------------------------------------------------------------
    | Error Tracking Variables
    | -------------------------------------------------------------------------
    /declare LastErrorMsg string outer
    /declare LastErrorTime string outer
    /declare MacroStartTime string outer ${Time.Date} ${Time.Time24}

/return

| ============================================================================
| SUB: Load All Settings
| ============================================================================
Sub LoadAllSettings
    /echo \ayLoading settings from ${IniFileName}...

    | Check if INI exists, create defaults if not
    /if (!${Ini[${IniFileName},General,Version].Length}) {
        /call CreateDefaultINI
    }

    | -------------------------------------------------------------------------
    | [General] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar General Role string Assist
    /call LoadIniVar General MainAssist string ${Me.CleanName}
    /call LoadIniVar General AssistAt int 98
    /call LoadIniVar General AssistOn int 1
    /call LoadIniVar General CampRadius int 50
    /call LoadIniVar General ReturnToCamp int 0
    /call LoadIniVar General ChaseAssist int 0
    /call LoadIniVar General ChaseDistance int 30

    | Set IAmMA flag - if I am the main assist, I pick my own targets
    /echo \ay[GronnzMaster] MainAssist="${MainAssist}" | MyName="${Me.CleanName}"
    /if (${MainAssist.Equal[${Me.CleanName}]}) {
        /varset IAmMA 1
        /echo \ag[GronnzMaster] I am the Main Assist (IAmMA=1) - will pick my own targets
    } else {
        /varset IAmMA 0
        /echo \ay[GronnzMaster] I am NOT the Main Assist (IAmMA=0) - will assist ${MainAssist}
    }
    /call LoadIniVar General MaxZRange int 50
    /call LoadIniVar General MedStart int 80
    /call LoadIniVar General MedStop int 95
    /call LoadIniVar General LootOn int 1
    /call LoadIniVar General UseNav int 1
    /call LoadIniVar General UseDanNet int 1
    /call LoadIniVar General DanNetBuffOn int 1
    /call LoadIniVar General ConditionsOn int 0
    /call LoadIniVar General AutoLaunchGUI int 0
    /call LoadIniVar General AutoLaunchHUD int 0

    | -------------------------------------------------------------------------
    | [Combat] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Combat MeleeOn int 1
    /call LoadIniVar Combat MeleeDistance int 25
    /call LoadIniVar Combat StickDistance int 15
    /call LoadIniVar Combat StickPoint string behind
    /call LoadIniVar Combat RangedOn int 0
    /call LoadIniVar Combat DPSOn int 1
    /call LoadIniVar Combat AutoFireOn int 0

    | -------------------------------------------------------------------------
    | [Heals] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Heals HealsOn int 1
    /call LoadIniVar Heals HealPct int 70
    /call LoadIniVar Heals HealGroupPct int 80
    /call LoadIniVar Heals EmergencyHealPct int 35
    /call LoadIniVar Heals MainHeal string
    /call LoadIniVar Heals QuickHeal string
    /call LoadIniVar Heals EmergencyHeal string
    /call LoadIniVar Heals HoT1 string
    /call LoadIniVar Heals HoT1Pct int 90
    /call LoadIniVar Heals GroupHeal string
    /call LoadIniVar Heals GroupHealPct int 70
    /call LoadIniVar Heals OOGHealPct int 60

    | -------------------------------------------------------------------------
    | [DPS] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar DPS NukeOn int 1
    /call LoadIniVar DPS DoTOn int 1
    /call LoadIniVar DPS NukeManaPct int 40
    /call LoadIniVar DPS DoTManaPct int 50
    /call LoadIniVar DPS StopDPSPct int 10
    /call LoadIniVar DPS Nuke1 string
    /call LoadIniVar DPS Nuke2 string
    /call LoadIniVar DPS Nuke3 string
    /call LoadIniVar DPS DoT1 string
    /call LoadIniVar DPS DoT2 string
    /call LoadIniVar DPS DoT3 string
    /call LoadIniVar DPS DoT4 string
    /call LoadIniVar DPS DoT5 string

    | -------------------------------------------------------------------------
    | [Debuffs] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Debuffs DebuffOn int 1
    /call LoadIniVar Debuffs Debuff1 string
    /call LoadIniVar Debuffs Debuff1Type string
    /call LoadIniVar Debuffs Debuff2 string
    /call LoadIniVar Debuffs Debuff2Type string
    /call LoadIniVar Debuffs Debuff3 string
    /call LoadIniVar Debuffs Debuff3Type string

    | -------------------------------------------------------------------------
    | [Burns] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Burns Burn1 string
    /call LoadIniVar Burns Burn1Type string
    /call LoadIniVar Burns Burn2 string
    /call LoadIniVar Burns Burn2Type string
    /call LoadIniVar Burns Burn3 string
    /call LoadIniVar Burns Burn3Type string

    | -------------------------------------------------------------------------
    | [Buffs] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Buffs BuffsOn int 1
    /call LoadIniVar Buffs RebuffOn int 1

    | -------------------------------------------------------------------------
    | [SelfBuffs] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar SelfBuffs SelfBuff1 string
    /call LoadIniVar SelfBuffs SelfBuff2 string
    /call LoadIniVar SelfBuffs SelfBuff3 string
    /call LoadIniVar SelfBuffs SelfBuff4 string
    /call LoadIniVar SelfBuffs SelfBuff5 string

    | -------------------------------------------------------------------------
    | [GroupBuffs] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar GroupBuffs GroupBuff1 string
    /call LoadIniVar GroupBuffs GroupBuff1Class string All
    /call LoadIniVar GroupBuffs GroupBuff2 string
    /call LoadIniVar GroupBuffs GroupBuff2Class string All
    /call LoadIniVar GroupBuffs GroupBuff3 string
    /call LoadIniVar GroupBuffs GroupBuff3Class string All
    /call LoadIniVar GroupBuffs GroupBuff4 string
    /call LoadIniVar GroupBuffs GroupBuff4Class string All
    /call LoadIniVar GroupBuffs GroupBuff5 string
    /call LoadIniVar GroupBuffs GroupBuff5Class string All

    | -------------------------------------------------------------------------
    | [PetBuffs] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar PetBuffs PetBuff1 string
    /call LoadIniVar PetBuffs PetBuff2 string
    /call LoadIniVar PetBuffs PetBuff3 string

    | -------------------------------------------------------------------------
    | [Pull] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Pull PullOn int 0
    /call LoadIniVar Pull PullRange int 200
    /call LoadIniVar Pull PullZRange int 50
    /call LoadIniVar Pull ChainPull int 0
    /call LoadIniVar Pull ChainPullHP int 20
    /call LoadIniVar Pull PullArc int 360
    /call LoadIniVar Pull PullNavOn int 1
    /call LoadIniVar Pull PullRanking int 0
    /call LoadIniVar Pull PullSpell string
    /call LoadIniVar PullAdvanced PullLocsOn int 0
    /call LoadPullLocs

    | -------------------------------------------------------------------------
    | [Pet] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Pet PetOn int 1
    /call LoadIniVar Pet PetHold int 0
    /call LoadIniVar Pet PetTaunt int 0

    | -------------------------------------------------------------------------
    | [Mez] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Mez MezOn int 0
    /call LoadIniVar Mez MezRadius int 50

    | -------------------------------------------------------------------------
    | [Slow] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Slow SlowOn int 0

    | -------------------------------------------------------------------------
    | [Charm] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Charm CharmOn int 0

    | -------------------------------------------------------------------------
    | [Items] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Items ItemClicksOn int 1

    | -------------------------------------------------------------------------
    | [OOG] Section (Out of Group)
    | -------------------------------------------------------------------------
    /call LoadIniVar OOG OOGOn int 0
    /call LoadIniVar OOG OOGHealOn int 0
    /call LoadIniVar OOG OOGBuffOn int 0
    /call LoadIniVar OOG OOGAssistOn int 0
    /call LoadIniVar OOG OOGRange int 200

    | -------------------------------------------------------------------------
    | [OOGBuffs] Section - Buffs for DanNet characters not in group
    | -------------------------------------------------------------------------
    /call LoadIniVar OOGBuffs OOGBuff1 string
    /call LoadIniVar OOGBuffs OOGBuff1Class string All
    /call LoadIniVar OOGBuffs OOGBuff2 string
    /call LoadIniVar OOGBuffs OOGBuff2Class string All
    /call LoadIniVar OOGBuffs OOGBuff3 string
    /call LoadIniVar OOGBuffs OOGBuff3Class string All
    /call LoadIniVar OOGBuffs OOGBuff4 string
    /call LoadIniVar OOGBuffs OOGBuff4Class string All
    /call LoadIniVar OOGBuffs OOGBuff5 string
    /call LoadIniVar OOGBuffs OOGBuff5Class string All

    | -------------------------------------------------------------------------
    | [Triggers] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Triggers Trigger1Text string TRIGGER1
    /call LoadIniVar Triggers Trigger2Text string TRIGGER2
    /call LoadIniVar Triggers Trigger3Text string TRIGGER3
    /call LoadIniVar Triggers Trigger4Text string TRIGGER4
    /call LoadIniVar Triggers Trigger5Text string TRIGGER5

    | -------------------------------------------------------------------------
    | [CHRotation] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar CHRotation CHRotOn int 0
    /call LoadIniVar CHRotation CHSpell string Complete Heal

    | -------------------------------------------------------------------------
    | [OnStart] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar OnStart Command1 string
    /call LoadIniVar OnStart Command2 string
    /call LoadIniVar OnStart Command3 string

    | -------------------------------------------------------------------------
    | [Cures] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Cures CuresOn int 1
    /call LoadIniVar Cures CurePoison int 1
    /call LoadIniVar Cures CureDisease int 1
    /call LoadIniVar Cures CureCurse int 1
    /call LoadIniVar Cures CureCorrupt int 0
    /call LoadIniVar Cures CureSpell1 string
    /call LoadIniVar Cures CureSpell1Type string
    /call LoadIniVar Cures CureSpell2 string
    /call LoadIniVar Cures CureSpell2Type string
    /call LoadIniVar Cures CureSpell3 string
    /call LoadIniVar Cures CureSpell3Type string

    | -------------------------------------------------------------------------
    | [Bard] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Bard MeleeTwistOn int 0
    /call LoadIniVar Bard MeleeTwist string
    /call LoadIniVar Bard CombatMelody string
    /call LoadIniVar Bard RestMelody string
    /call LoadIniVar Bard PullMelody string

    | -------------------------------------------------------------------------
    | [FD] Section (Feign Death)
    | -------------------------------------------------------------------------
    /call LoadIniVar FD FDOn int 0
    /call LoadIniVar FD FDHPPct int 20
    /call LoadIniVar FD FDSpell string
    /call LoadIniVar FD FDSplitPull int 0
    /call LoadIniVar FD FDAggroCheck int 1
    /call LoadIniVar FD FDAggroDelay int 50

    | -------------------------------------------------------------------------
    | [Merc] Section (Mercenary)
    | -------------------------------------------------------------------------
    /call LoadIniVar Merc MercOn int 0
    /call LoadIniVar Merc MercAssist int 1
    /call LoadIniVar Merc MercStance string balanced

    | -------------------------------------------------------------------------
    | [OffTank] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar OffTank OffTankOn int 0
    /call LoadIniVar OffTank MAFailoverDelay int 30

    | -------------------------------------------------------------------------
    | [AE] Section (AE Check)
    | -------------------------------------------------------------------------
    /call LoadIniVar AE AECheckOn int 0
    /call LoadIniVar AE AEFleeRange int 50
    /call LoadIniVar AE AEFleeHP int 50
    /call LoadIniVar AE AEMobCount int 3
    /call LoadIniVar AE AERunToWP string

    | -------------------------------------------------------------------------
    | [Corpse] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Corpse CorpseRecoveryOn int 0
    /call LoadIniVar Corpse CorpseSummonOn int 0
    /call LoadIniVar Corpse CorpseSummonSpell string

    | -------------------------------------------------------------------------
    | [Campfire] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar Campfire CampfireOn int 0
    /call LoadIniVar Campfire ClickBacktoCamp int 0
    /call LoadIniVar Campfire FellowshipRecallOn int 0

    | -------------------------------------------------------------------------
    | [PetToys] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar PetToys PetToysOn int 0

    | -------------------------------------------------------------------------
    | [AFK] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar AFK AFKToolsOn int 0
    /call LoadIniVar AFK AFKReply string I am AFK using GronnzMaster.
    /call LoadIniVar AFK AFKAutoReply int 0

    | -------------------------------------------------------------------------
    | [GroupWatch] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar GroupWatch GroupWatchOn int 0
    /call LoadIniVar GroupWatch GroupWatchHealPct int 50
    /call LoadIniVar GroupWatch GroupWatchAlertDead int 1

    | -------------------------------------------------------------------------
    | [HunterMode] Section
    | -------------------------------------------------------------------------
    /call LoadIniVar HunterMode HunterMode int 0
    /call LoadIniVar HunterMode HunterMinMobs int 0
    /call LoadIniVar HunterMode HunterMaxMobs int 10
    /call LoadIniVar HunterMode HunterRadius int 500
    /call LoadIniVar HunterMode HunterZRadius int 100

    | -------------------------------------------------------------------------
    | Auxiliary files
    | -------------------------------------------------------------------------
    /call EnsureConditionsFile
    /call LoadLists

    | Set IAmABard flag
    /if (${Me.Class.ShortName.Equal[BRD]}) {
        /varset IAmABard 1
    }

    /echo \agSettings loaded successfully!
/return

| ============================================================================
| SUB: Save All Settings to INI
| ============================================================================
Sub SaveAllSettings
    /echo \aySaving settings to ${IniFileName}...

    | -------------------------------------------------------------------------
    | [General] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "General" "Version" "${GVERSION}"
    /ini "${IniFileName}" "General" "Role" "${Role}"
    /ini "${IniFileName}" "General" "MainAssist" "${MainAssist}"
    /ini "${IniFileName}" "General" "AssistAt" "${AssistAt}"
    /ini "${IniFileName}" "General" "CampRadius" "${CampRadius}"
    /ini "${IniFileName}" "General" "ReturnToCamp" "${ReturnToCamp}"
    /ini "${IniFileName}" "General" "ChaseAssist" "${ChaseAssist}"
    /ini "${IniFileName}" "General" "ChaseDistance" "${ChaseDistance}"
    /ini "${IniFileName}" "General" "MaxZRange" "${MaxZRange}"
    /ini "${IniFileName}" "General" "MedStart" "${MedStart}"
    /ini "${IniFileName}" "General" "MedStop" "${MedStop}"
    /ini "${IniFileName}" "General" "LootOn" "${LootOn}"
    /ini "${IniFileName}" "General" "UseNav" "${UseNav}"
    /ini "${IniFileName}" "General" "UseDanNet" "${UseDanNet}"

    | -------------------------------------------------------------------------
    | [Combat] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "Combat" "MeleeOn" "${MeleeOn}"
    /ini "${IniFileName}" "Combat" "MeleeDistance" "${MeleeDistance}"
    /ini "${IniFileName}" "Combat" "StickDistance" "${StickDistance}"
    /ini "${IniFileName}" "Combat" "StickPoint" "${StickPoint}"
    /ini "${IniFileName}" "Combat" "RangedOn" "${RangedOn}"
    /ini "${IniFileName}" "Combat" "DPSOn" "${DPSOn}"
    /ini "${IniFileName}" "Combat" "AutoFireOn" "${AutoFireOn}"

    | -------------------------------------------------------------------------
    | [Heals] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "Heals" "HealsOn" "${HealsOn}"
    /ini "${IniFileName}" "Heals" "HealPct" "${HealPct}"
    /ini "${IniFileName}" "Heals" "HealGroupPct" "${HealGroupPct}"
    /ini "${IniFileName}" "Heals" "EmergencyHealPct" "${EmergencyHealPct}"

    | -------------------------------------------------------------------------
    | [Buffs] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "Buffs" "BuffsOn" "${BuffsOn}"
    /ini "${IniFileName}" "Buffs" "RebuffOn" "${RebuffOn}"

    | -------------------------------------------------------------------------
    | [Pull] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "Pull" "PullOn" "${PullOn}"
    /ini "${IniFileName}" "Pull" "PullRange" "${PullRange}"
    /ini "${IniFileName}" "Pull" "PullZRange" "${PullZRange}"
    /ini "${IniFileName}" "Pull" "ChainPull" "${ChainPull}"
    /ini "${IniFileName}" "Pull" "ChainPullHP" "${ChainPullHP}"
    /ini "${IniFileName}" "Pull" "PullArc" "${PullArc}"
    /ini "${IniFileName}" "Pull" "PullNavOn" "${PullNavOn}"
    /ini "${IniFileName}" "Pull" "PullRanking" "${PullRanking}"
    /ini "${IniFileName}" "Pull" "PullSpell" "${PullSpell}"
    /ini "${IniFileName}" "PullAdvanced" "PullLocsOn" "${PullLocsOn}"
    /declare PullLocStr string local
    /for i 1 to ${MAXPULLLOCS}
        /if (${PullLocRadius[${i}]} > 0) {
            /varset PullLocStr ${PullLocY[${i}]}|${PullLocX[${i}]}|${PullLocRadius[${i}]}
        } else {
            /varset PullLocStr
        }
        /ini "${IniFileName}" "PullAdvanced" "PullLoc${i}" "${PullLocStr}"
    /next i

    | -------------------------------------------------------------------------
    | [Pet] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "Pet" "PetOn" "${PetOn}"
    /ini "${IniFileName}" "Pet" "PetHold" "${PetHold}"
    /ini "${IniFileName}" "Pet" "PetTaunt" "${PetTaunt}"

    | -------------------------------------------------------------------------
    | [Mez] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "Mez" "MezOn" "${MezOn}"
    /ini "${IniFileName}" "Mez" "MezRadius" "${MezRadius}"

    | -------------------------------------------------------------------------
    | [Slow] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "Slow" "SlowOn" "${SlowOn}"

    | -------------------------------------------------------------------------
    | [Charm] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "Charm" "CharmOn" "${CharmOn}"

    | -------------------------------------------------------------------------
    | [Items] Section
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "Items" "ItemClicksOn" "${ItemClicksOn}"

    | -------------------------------------------------------------------------
    | [OOG] Section (Out of Group)
    | -------------------------------------------------------------------------
    /ini "${IniFileName}" "OOG" "OOGOn" "${OOGOn}"
    /ini "${IniFileName}" "OOG" "OOGHealOn" "${OOGHealOn}"
    /ini "${IniFileName}" "OOG" "OOGBuffOn" "${OOGBuffOn}"
    /ini "${IniFileName}" "OOG" "OOGAssistOn" "${OOGAssistOn}"
    /ini "${IniFileName}" "OOG" "OOGRange" "${OOGRange}"

    /echo \agSettings saved to ${IniFileName}!
/return

| ============================================================================
| SUB: Load INI Variable
| ============================================================================
Sub LoadIniVar(string Section, string VarName, string VarType, string Default)
    /declare Value string local ${Ini[${IniFileName},${Section},${VarName}]}

    /if (!${Value.Length} || ${Value.Equal[NULL]}) {
        /varset Value ${Default}
        /ini "${IniFileName}" "${Section}" "${VarName}" "${Default}"
    }

    /if (${Defined[${VarName}]}) {
        /varset ${VarName} ${Value}
    } else {
        /declare ${VarName} ${VarType} outer ${Value}
    }

    GZMDEBUG Loaded ${Section}/${VarName} = ${Value}
/return

| ============================================================================
| SUB: Create Default INI
| ============================================================================
Sub CreateDefaultINI
    /echo \ayCreating default INI file: ${IniFileName}

    /ini "${IniFileName}" "General" "Version" "${GVERSION}"
    /ini "${IniFileName}" "General" "Role" "Assist"
    /ini "${IniFileName}" "General" "MainAssist" "${Me.CleanName}"
    /ini "${IniFileName}" "General" "AssistAt" "98"
    /ini "${IniFileName}" "General" "CampRadius" "50"
    /ini "${IniFileName}" "General" "ReturnToCamp" "0"
    /ini "${IniFileName}" "General" "ChaseAssist" "0"
    /ini "${IniFileName}" "General" "ChaseDistance" "30"
    /ini "${IniFileName}" "General" "MaxZRange" "50"
    /ini "${IniFileName}" "General" "MedStart" "80"
    /ini "${IniFileName}" "General" "MedStop" "95"
    /ini "${IniFileName}" "General" "LootOn" "1"
    /ini "${IniFileName}" "General" "UseNav" "1"
    /ini "${IniFileName}" "General" "UseDanNet" "1"
    /ini "${IniFileName}" "General" "ConditionsOn" "0"
    /ini "${IniFileName}" "General" "AutoLaunchGUI" "0"
    /ini "${IniFileName}" "General" "AutoLaunchHUD" "0"

    /ini "${IniFileName}" "Combat" "MeleeOn" "1"
    /ini "${IniFileName}" "Combat" "MeleeDistance" "25"
    /ini "${IniFileName}" "Combat" "StickDistance" "15"
    /ini "${IniFileName}" "Combat" "StickPoint" "behind"
    /ini "${IniFileName}" "Combat" "RangedOn" "0"
    /ini "${IniFileName}" "Combat" "DPSOn" "1"

    /ini "${IniFileName}" "Heals" "HealsOn" "1"
    /ini "${IniFileName}" "Heals" "HealPct" "70"
    /ini "${IniFileName}" "Heals" "HealGroupPct" "80"
    /ini "${IniFileName}" "Heals" "EmergencyHealPct" "35"
    /ini "${IniFileName}" "Heals" "OOGHealPct" "60"

    /ini "${IniFileName}" "Buffs" "BuffsOn" "1"
    /ini "${IniFileName}" "Buffs" "RebuffOn" "1"

    /ini "${IniFileName}" "Pull" "PullOn" "0"
    /ini "${IniFileName}" "Pull" "PullRange" "200"
    /ini "${IniFileName}" "Pull" "ChainPull" "0"
    /ini "${IniFileName}" "Pull" "PullNavOn" "1"
    /ini "${IniFileName}" "Lists" "PullList" ""
    /ini "${IniFileName}" "Lists" "IgnoreList" ""
    /ini "${IniFileName}" "PullAdvanced" "PullLocsOn" "0"
    /ini "${IniFileName}" "PullAdvanced" "PullLoc1" ""
    /ini "${IniFileName}" "PullAdvanced" "PullLoc2" ""
    /ini "${IniFileName}" "PullAdvanced" "PullLoc3" ""
    /ini "${IniFileName}" "PullAdvanced" "PullLoc4" ""
    /ini "${IniFileName}" "PullAdvanced" "PullLoc5" ""

    /ini "${IniFileName}" "Pet" "PetOn" "1"
    /ini "${IniFileName}" "Pet" "PetHold" "0"

    /ini "${IniFileName}" "Mez" "MezOn" "0"
    /ini "${IniFileName}" "Mez" "MezRadius" "50"

    /ini "${IniFileName}" "OOG" "OOGOn" "0"
    /ini "${IniFileName}" "OOG" "OOGHealOn" "0"
    /ini "${IniFileName}" "OOG" "OOGBuffOn" "0"
    /ini "${IniFileName}" "OOG" "OOGAssistOn" "0"
    /ini "${IniFileName}" "OOG" "OOGRange" "200"

    /ini "${IniFileName}" "Triggers" "Trigger1Text" "TRIGGER1"
    /ini "${IniFileName}" "Triggers" "Trigger2Text" "TRIGGER2"

    /ini "${IniFileName}" "CHRotation" "CHRotOn" "0"
    /ini "${IniFileName}" "CHRotation" "CHSpell" "Complete Heal"

    /ini "${IniFileName}" "OnStart" "Command1" ""

    /echo \agDefault INI created!
/return

| ============================================================================
| SUB: Setup Communication (Enhanced - supports DanNet + EQBC/NetBots fallback)
| ============================================================================
Sub SetupCommunication
    /echo \ayConfiguring communication...

    | Use unified communication system if available (gzm_comm.inc)
    /if (${Defined[InitCommVars]}) {
        /call InitCommVars
        /call InitComm
        /return
    }

    | Fallback: Legacy communication setup
    | Primary: DanNet (works local + LAN)
    /if (${UseDanNet} && ${Plugin[MQ2DanNet].Name.Length}) {
        /echo \ag  DanNet: ACTIVE (Primary)
        /squelch /dnet commandecho off
    } else {
        /echo \ar  DanNet: NOT AVAILABLE
        /varset UseDanNet 0
    }

    | Secondary: EQBC (fallback for multi-PC/internet)
    /if (${Plugin[MQ2EQBC].Name.Length}) {
        /if (${EQBC.Connected}) {
            /echo \ag  EQBC: CONNECTED ${If[${UseDanNet},(Fallback),(Primary)]}
            /varset UseEQBC 1
        } else {
            /echo \ay  EQBC: Plugin loaded but not connected
            /echo \ay  (Use /bccmd connect <server> to connect)
            /varset UseEQBC 0
        }
    } else {
        /echo \aw  EQBC: Not loaded
        /varset UseEQBC 0
    }

    | Check NetBots if EQBC is connected
    /if (${UseEQBC} && ${Plugin[MQ2NetBots].Name.Length}) {
        /if (${NetBots.Client.Length}) {
            /echo \ag  NetBots: ACTIVE - ${NetBots.Counts} clients
            /varset UseNetBots 1
        }
    }

    | Fallback check
    /if (!${UseDanNet} && !${UseEQBC}) {
        /echo \arWARNING: No communication method available!
        /echo \ar  Multi-boxing features will be limited.
        /echo \ar  Load MQ2DanNet or connect to EQBC server.
    }
/return

| ============================================================================
| SUB: Setup DanNet Observers
| ============================================================================
Sub SetupDanNetObservers
    /if (${DanNetObserversSetup}) /return
    /if (!${UseDanNet}) /return
    /if (!${Plugin[MQ2DanNet].Name.Length}) /return

    | Register observers for this character (so others can query us)
    /squelch /dobserve ${Me.CleanName} -q Target.ID
    /squelch /dobserve ${Me.CleanName} -q Target.CleanName
    /squelch /dobserve ${Me.CleanName} -q Me.PctHPs
    /squelch /dobserve ${Me.CleanName} -q Me.PctMana
    /squelch /dobserve ${Me.CleanName} -q Me.PctEndurance
    /squelch /dobserve ${Me.CleanName} -q Me.Combat
    /squelch /dobserve ${Me.CleanName} -q Me.Casting.ID
    /squelch /dobserve ${Me.CleanName} -q Me.State
    /squelch /dobserve ${Me.CleanName} -q Me.XTarget[1].ID

    /varset DanNetObserversSetup 1
    /echo \ag[GronnzMaster] DanNet observers configured.
/return

| ============================================================================
| SUB: Setup Aliases
| ============================================================================
Sub SetupAliases
    /declare StoredVersion string local ${Ini[${IniFileName},General,Version]}

    /if (${StoredVersion.NotEqual[${GVERSION}]}) {
        /echo \ayVersion change detected - updating aliases...

        | Core aliases
        | /gm is now handled by #bind GMCommand - no alias needed
        /squelch /alias /gmhelp /echo [MQ2] GMHelp
        /squelch /alias /gmstatus /echo [MQ2] GMStatus

        | Combat aliases
        /squelch /alias /buffson /togglevariable BuffsOn
        /squelch /alias /meleeon /togglevariable MeleeOn
        /squelch /alias /healson /togglevariable HealsOn
        /squelch /alias /dpson /togglevariable DPSOn
        /squelch /alias /peton /togglevariable PetOn
        /squelch /alias /mezon /togglevariable MezOn

        | Movement aliases
        /squelch /alias /camphere /makecamphere
        /squelch /alias /chase /togglevariable ChaseAssist
        /squelch /alias /chaseon /changevarint General ChaseAssist 1
        /squelch /alias /chaseoff /changevarint General ChaseAssist 0
        /squelch /alias /returntocamp /togglevariable ReturnToCamp

        | Pull aliases
        /squelch /alias /pullon /togglevariable PullOn
        /squelch /alias /pullhold /togglevariable PullHold
        /squelch /alias /chainpull /togglevariable ChainPull

        | OOG aliases
        /squelch /alias /oogon /togglevariable OOGOn

        | Utility aliases
        /squelch /alias /looton /togglevariable LootOn
        /squelch /alias /navon /togglevariable UseNav
        /squelch /alias /assiston /togglevariable AssistOn

        /ini "${IniFileName}" "General" "Version" "${GVERSION}"
        /echo \agAliases updated!
    }
/return

| ============================================================================
| SUB: Run OnStart Commands
| ============================================================================
Sub RunOnStart
    /declare cmd string local
    /declare i int local

    /for i 1 to 3
        /varset cmd ${Ini[${IniFileName},OnStart,Command${i}]}
        /if (${cmd.Length} && ${cmd.NotEqual[NULL]}) {
            /echo \ayOnStart: Executing Command${i}: ${cmd}
            | Handle pipe-separated commands
            /if (${cmd.Find[|]}) {
                /call ExecutePipedCommands "${cmd}"
            } else {
                /${cmd}
            }
        }
    /next i
/return

| ============================================================================
| SUB: Execute Piped Commands (command1|command2|command3)
| ============================================================================
Sub ExecutePipedCommands(string Commands)
    /declare cmd string local
    /declare remaining string local ${Commands}
    /declare pipePos int local

    :NextCommand
    /varset pipePos ${remaining.Find[|]}
    /if (${pipePos}) {
        /varset cmd ${remaining.Left[${Math.Calc[${pipePos}-1]}]}
        /varset remaining ${remaining.Right[${Math.Calc[${remaining.Length}-${pipePos}]}]}
        /${cmd}
        /delay 5
        /goto :NextCommand
    } else /if (${remaining.Length}) {
        /${remaining}
    }
/return

| ============================================================================
| SUB: Auto Launch Optional UI
| ============================================================================
Sub AutoLaunchUI
    /if (!${Plugin[MQ2Lua].Name.Length}) /return

    /if (${AutoLaunchGUI} && !${Lua.Script[GronnzMaster_gui].Running}) {
        /echo \ag[GronnzMaster] Launching GronnzMaster_gui.lua
        /lua run GronnzMaster_gui
    }

    /if (${AutoLaunchHUD} && !${Lua.Script[GronnzMaster_hud].Running}) {
        /echo \ag[GronnzMaster] Launching GronnzMaster_hud.lua
        /lua run GronnzMaster_hud
    }
/return

| ============================================================================
| SUB: Ensure Conditions File Exists
| ============================================================================
Sub EnsureConditionsFile
    /declare CondVersion string local ${Ini[${ConditionsFileName},Meta,Version]}
    /if (${CondVersion.Length}) /return

    /echo \ay[GronnzMaster] Creating default conditions file: ${ConditionsFileName}
    /ini "${ConditionsFileName}" "Meta" "Version" "${GVERSION}"

    | Buffs
    /ini "${ConditionsFileName}" "Buffs" "SelfBuff1" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "SelfBuff2" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "SelfBuff3" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "SelfBuff4" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "SelfBuff5" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "GroupBuff1" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "GroupBuff2" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "GroupBuff3" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "GroupBuff4" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "GroupBuff5" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "PetBuff1" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "PetBuff2" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "PetBuff3" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "OOGBuff1" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "OOGBuff2" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "OOGBuff3" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "OOGBuff4" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Buffs" "OOGBuff5" "${DEFAULT_CONDITION}"

    | Heals
    /ini "${ConditionsFileName}" "Heals" "MainHeal" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Heals" "QuickHeal" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Heals" "EmergencyHeal" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Heals" "GroupHeal" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Heals" "HoT1" "${DEFAULT_CONDITION}"

    | DPS
    /ini "${ConditionsFileName}" "DPS" "Nuke1" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "DPS" "Nuke2" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "DPS" "Nuke3" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "DPS" "DoT1" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "DPS" "DoT2" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "DPS" "DoT3" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "DPS" "DoT4" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "DPS" "DoT5" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Debuffs" "Debuff1" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Debuffs" "Debuff2" "${DEFAULT_CONDITION}"
    /ini "${ConditionsFileName}" "Debuffs" "Debuff3" "${DEFAULT_CONDITION}"

    | Pull
    /ini "${ConditionsFileName}" "Pull" "PullSpell" "${DEFAULT_CONDITION}"
/return

| ============================================================================
| SUB: ConditionOK - evaluates condition entries
| ============================================================================
Sub ConditionOK(string Section, string Entry)
    /if (!${ConditionsOn}) /return 1
    /declare CondExpr string local ${Ini[${ConditionsFileName},${Section},${Entry}]}
    /if (!${CondExpr.Length}) /return 1
    /if (${CondExpr.Equal[TRUE]} || ${CondExpr.Equal[1]}) /return 1
    /if (${CondExpr.Equal[FALSE]} || ${CondExpr.Equal[0]}) /return 0

    /declare ConditionResult int local 0
    /declare EvalCmd string local /if (${CondExpr}) /varset ConditionResult 1
    /docommand "${EvalCmd}"
/return ${ConditionResult}

| ============================================================================
| SUB: GM INI Command - View or set INI values from game
| ============================================================================
Sub GMIniCommand(string Section, string Key, string Value)
    /if (!${Section.Length} || !${Key.Length}) {
        /echo \arUsage: /gm ini <section> <key> [value]
        /return
    }

    /declare Current string local ${Ini[${IniFileName},${Section},${Key}]}

    | Read mode when no value supplied
    /if (!${Value.Length}) {
        /if (${Current.Length}) {
            /echo \ag${Section}.${Key} = ${Current}
        } else {
            /echo \ay${Section}.${Key} not set in ${IniFileName}
        }
        /return
    }

    | Write value to INI
    /ini "${IniFileName}" "${Section}" "${Key}" "${Value}"
    /echo \ag${Section}.${Key} set to "${Value}"
/return

| ============================================================================
| SUB: GM Condition Command - View/update condition expressions
| ============================================================================
Sub GMConditionCommand(string Section, string Entry, string Expr)
    /call EnsureConditionsFile
    /if (!${Section.Length} || !${Entry.Length}) {
        /echo \arUsage: /gm cond <section> <entry> [expression]
        /return
    }

    /declare Current string local ${Ini[${ConditionsFileName},${Section},${Entry}]}
    /if (!${Current.Length}) /varset Current ${DEFAULT_CONDITION}

    | View mode (no expression supplied)
    /if (!${Expr.Length}) {
        /echo \agCondition ${Section}.${Entry} = ${Current}
        /return
    }

    /ini "${ConditionsFileName}" "${Section}" "${Entry}" "${Expr}"
    /echo \agCondition ${Section}.${Entry} updated to ${Expr}
/return

| ============================================================================
| SUB: Load Pull Locations
| ============================================================================
Sub LoadPullLocs
    /declare i int local
    /declare loc string local
    /varset PullLocCount 0

    /for i 1 to ${MAXPULLLOCS}
        /varset PullLocY[${i}] 0
        /varset PullLocX[${i}] 0
        /varset PullLocRadius[${i}] 0
        /varset loc ${Ini[${IniFileName},PullAdvanced,PullLoc${i}]}
        /if (${loc.Length}) {
            /varset PullLocY[${i}] ${loc.Arg[1,|]}
            /varset PullLocX[${i}] ${loc.Arg[2,|]}
            /varset PullLocRadius[${i}] ${loc.Arg[3,|]}
            /if (!${PullLocRadius[${i}]}) /varset PullLocRadius[${i}] 50
            /varcalc PullLocCount ${PullLocCount}+1
        }
    /next i
    /if (!${PullLocCount}) /varset PullLocsOn 0
/return

| ============================================================================
| SUB: Save Pull Locations
| ============================================================================
Sub SavePullLocs
    /declare i int local
    /declare PullLocStr string local
    /for i 1 to ${MAXPULLLOCS}
        /if (${PullLocRadius[${i}]} > 0) {
            /varset PullLocStr ${PullLocY[${i}]}|${PullLocX[${i}]}|${PullLocRadius[${i}]}
        } else {
            /varset PullLocStr
        }
        /ini "${IniFileName}" "PullAdvanced" "PullLoc${i}" "${PullLocStr}"
    /next i
    /ini "${IniFileName}" "PullAdvanced" "PullLocsOn" "${PullLocsOn}"
/return

| ============================================================================
| SUB: Add Pull Location
| ============================================================================
Sub AddPullLoc(float NewY, float NewX, float Radius)
    /declare idx int local
    /if (${Radius} <= 0) /varset Radius 50

    /for idx 1 to ${MAXPULLLOCS}
        /if (${PullLocRadius[${idx}]} <= 0) {
            /varset PullLocY[${idx}] ${NewY}
            /varset PullLocX[${idx}] ${NewX}
            /varset PullLocRadius[${idx}] ${Radius}
            /varset PullLocsOn 1
            /call SavePullLocs
            /call LoadPullLocs
            /echo \ag[PullLoc] Added slot ${idx}: Y=${NewY} X=${NewX} Radius=${Radius}
            /return
        }
    /next idx

    /echo \ar[PullLoc] All ${MAXPULLLOCS} slots are in use. Clear one before adding.
/return

| ============================================================================
| SUB: Clear Pull Location (Index 0 = all)
| ============================================================================
Sub ClearPullLoc(int Index)
    /declare idx int local
    /if (${Index} <= 0) {
        /for idx 1 to ${MAXPULLLOCS}
            /varset PullLocY[${idx}] 0
            /varset PullLocX[${idx}] 0
            /varset PullLocRadius[${idx}] 0
        /next idx
        /varset PullLocCount 0
        /varset PullLocsOn 0
        /call SavePullLocs
        /echo \ay[PullLoc] Cleared all pull locations.
        /return
    }

    /if (${Index} > ${MAXPULLLOCS}) {
        /echo \ar[PullLoc] Invalid slot ${Index}
        /return
    }

    /varset PullLocY[${Index}] 0
    /varset PullLocX[${Index}] 0
    /varset PullLocRadius[${Index}] 0
    /call SavePullLocs
    /call LoadPullLocs
    /echo \ay[PullLoc] Cleared slot ${Index}.
/return

| ============================================================================
| SUB: Show Pull Locations
| ============================================================================
Sub ShowPullLocs
    /declare idx int local
    /if (!${PullLocCount}) {
        /echo \ay[PullLoc] No locations defined.
        /return
    }

    /echo \ag[PullLoc] Listing active pull locations:
    /for idx 1 to ${MAXPULLLOCS}
        /if (${PullLocRadius[${idx}]} > 0) {
            /echo \aw  Slot ${idx}: Y=${PullLocY[${idx}]} X=${PullLocX[${idx}]} Radius=${PullLocRadius[${idx}]}
        }
    /next idx
/return

| ============================================================================
| SUB: Should Avoid Mob (Pull Loc restrictions)
| ============================================================================
Sub ShouldAvoidMob(int MobID)
    /if (!${MobID}) /return 0
    /if (!${PullLocsOn}) /return 0
    /if (!${PullLocCount}) /return 0

    /declare mobY float local ${Spawn[${MobID}].Y}
    /declare mobX float local ${Spawn[${MobID}].X}
    /declare idx int local
    /declare dist float local

    /for idx 1 to ${MAXPULLLOCS}
        /if (${PullLocRadius[${idx}]} > 0) {
            /varset dist ${Math.Distance[${mobY},${mobX}:${PullLocY[${idx}]},${PullLocX[${idx}]}]}
            /if (${dist} <= ${PullLocRadius[${idx}]}) /return 1
        }
    /next idx
/return 0

| ============================================================================
| SUB: Load Pull / Ignore Lists
| ============================================================================
Sub LoadLists
    /varset PullList ${Ini[${IniFileName},Lists,PullList]}
    /varset IgnoreList ${Ini[${IniFileName},Lists,IgnoreList]}
/return

| ============================================================================
| SUB: Save List
| ============================================================================
Sub SaveList(string ListType, string Data)
    /if (${ListType.Equal[Pull]}) {
        /varset PullList ${Data}
        /ini "${IniFileName}" "Lists" "PullList" "${Data}"
    } else {
        /varset IgnoreList ${Data}
        /ini "${IniFileName}" "Lists" "IgnoreList" "${Data}"
    }
/return

| ============================================================================
| SUB: ListContains
| ============================================================================
Sub ListContains(string ListData, string Name)
    /if (!${ListData.Length}) /return 0
    /declare entries int local ${Math.Calc[${ListData.Count[|]}+1]}
    /declare idx int local 1
    /declare token string local
    /for idx 1 to ${entries}
        /varset token ${ListData.Arg[${idx},|]}
        /if (!${token.Length}) /next idx
        /if (${token.Lower.Equal[${Name.Lower}]}) /return 1
    /next idx
/return 0

| ============================================================================
| SUB: AddNameToList
| ============================================================================
Sub AddNameToList(string ListType, string Name)
    /declare CleanName string local ${Name}
    /if (!${CleanName.Length}) /return
    /declare Current string local ${If[${ListType.Equal[Pull]},${PullList},${IgnoreList}]}
    /call ListContains "${Current}" "${CleanName}"
    /if (${Macro.Return}) {
        /echo \ay${CleanName} already exists in ${ListType} list.
        /return
    }
    /if (${Current.Length}) {
        /varset Current ${Current}|${CleanName}
    } else {
        /varset Current ${CleanName}
    }
    /call SaveList ${ListType} "${Current}"
    /echo \ag${CleanName} added to ${ListType} list.
/return

| ============================================================================
| SUB: ShowList
| ============================================================================
Sub ShowList(string ListType)
    /declare Current string local ${If[${ListType.Equal[Pull]},${PullList},${IgnoreList}]}
    /if (!${Current.Length}) {
        /echo \ay${ListType} list is empty.
        /return
    }
    /declare entries int local ${Math.Calc[${Current.Count[|]}+1]}
    /declare idx int local 1
    /declare token string local
    /echo \ag${ListType} list entries:
    /for idx 1 to ${entries}
        /varset token ${Current.Arg[${idx},|]}
        /if (!${token.Length}) /next idx
        /echo \aw  - ${token}
    /next idx
/return


| ============================================================================
| SUB: Check Emergency
| ============================================================================
Sub CheckEmergency
    | Check for low health emergency
    /if (${Me.PctHPs} < ${EmergencyHealPct}) {
        GZMDEBUG_HEAL EMERGENCY: Health at ${Me.PctHPs}%
        /call DoEmergencyHeal
    }

    | Check for aggro when not tank
    /if (!${Select[${Role},Tank,PullerTank,HunterTank,PetTank]} && ${Me.TargetOfTarget.ID} == ${Me.ID}) {
        GZMDEBUG_COMBAT WARNING: I have aggro!
        | Could add fade/FD logic here
    }
/return

| ============================================================================
| SUB: Check Healing
| ============================================================================
Sub CheckHealing
    /if (${HealTimer}) /return

    | -------------------------------------------------------------------------
    | Class-specific healing behavior
    | -------------------------------------------------------------------------

    | Pure Tanks (WAR): Cannot heal at all - skip entirely
    /if (${IsPureTank}) /return

    | Lifetap Classes (SHD, NEC): Heal through DPS, not traditional heals
    | Their "healing" comes from offensive lifetap spells in their DPS rotation
    /if (${IsLifetapClass}) /return

    | Hybrid Tank/Healer (PAL): Special handling based on role
    | - When tanking: Only heal self, don't switch targets to heal others
    | - When healing: Normal healer behavior
    /if (${IsHybridTankHealer}) {
        /if (${Select[${Role},Tank,PullerTank,HunterTank]}) {
            | Paladin tanking - only self heal, never switch targets
            /if (${Me.PctHPs} < ${HealPct}) {
                GZMDEBUG_HEAL PAL Tank: Self heal at ${Me.PctHPs}%
                /call HealSelfOnly
            }
            /varset HealTimer 5
            /return
        }
        | Paladin in healer role - fall through to normal healing
    }

    GZMDEBUG_HEAL Checking heals...

    | Check self first
    /if (${Me.PctHPs} < ${HealPct}) {
        /call HealTarget ${Me.ID}
        /return
    }

    | Check group
    /call CheckGroupHealth

    | Check OOG targets
    /if (${OOGHealOn}) {
        /call CheckOOGHealth
    }

    /varset HealTimer 5
    /if (${Defined[CustomHealHook]}) /call CustomHealHook
/return

| ============================================================================
| SUB: Heal Self Only - For tanks who can heal but shouldn't switch targets
| Used by Paladins when tanking - uses -targetid to avoid target switching
| ============================================================================
Sub HealSelfOnly
    /if (${Me.Casting.ID}) /return

    /declare HealSpell string local

    | Determine best heal spell
    /if (${Me.PctHPs} < ${EmergencyHealPct} && ${EmergencyHeal.Length} && ${Me.Book[${EmergencyHeal}]}) {
        /call ConditionOK Heals EmergencyHeal
        /if (${Macro.Return}) /varset HealSpell ${EmergencyHeal}
    }
    /if (!${HealSpell.Length} && ${MainHeal.Length} && ${Me.Book[${MainHeal}]}) {
        /call ConditionOK Heals MainHeal
        /if (${Macro.Return}) /varset HealSpell ${MainHeal}
    }

    /if (!${HealSpell.Length}) /return

    | Check mana and spell ready
    /if (${Spell[${HealSpell}].Mana} > ${Me.CurrentMana}) /return
    /if (!${Me.SpellReady[${HealSpell}]}) /return

    | Cast on self using -targetid (no target switching!)
    GZMDEBUG_HEAL Self heal: ${HealSpell} (no target switch)
    /casting "${HealSpell}" -targetid|${Me.ID}
    /delay 5 ${Me.Casting.ID}
    /delay 15s !${Me.Casting.ID}
    /varset HealsCast ${Math.Calc[${HealsCast}+1]}
/return

| ============================================================================
| SUB: Check Group Health
| ============================================================================
Sub CheckGroupHealth
    /declare i int local
    /declare lowestID int local 0
    /declare lowestPct int local 100

    /for i 0 to ${Group.Members}
        /if (${Group.Member[${i}].ID} && ${Group.Member[${i}].PctHPs} < ${lowestPct} && ${Group.Member[${i}].Distance} < 200) {
            /varset lowestPct ${Group.Member[${i}].PctHPs}
            /varset lowestID ${Group.Member[${i}].ID}
        }
    /next i

    /if (${lowestPct} < ${HealGroupPct} && ${lowestID}) {
        GZMDEBUG_HEAL Group member ${Spawn[${lowestID}].CleanName} at ${lowestPct}%
        /call HealTarget ${lowestID}
    }
/return

| ============================================================================
| SUB: Heal Target
| Uses MQ2Cast -targetid to heal WITHOUT changing current target
| ============================================================================
Sub HealTarget(int TargetID)
    /if (${Me.Casting.ID}) /return
    /if (${Me.PctMana} < 10) /return

    /declare HealSpell string local
    /declare TargetPct int local ${Spawn[id ${TargetID}].PctHPs}

    GZMDEBUG_HEAL Healing ${Spawn[${TargetID}].CleanName} at ${TargetPct}%

    | Determine which heal to use based on target HP - priority order
    /if (${TargetPct} < ${EmergencyHealPct} && ${EmergencyHeal.Length} && ${Me.Book[${EmergencyHeal}]}) {
        /call ConditionOK Heals EmergencyHeal
        /if (${Macro.Return}) /varset HealSpell ${EmergencyHeal}
    }
    /if (!${HealSpell.Length} && ${TargetPct} < 50 && ${QuickHeal.Length} && ${Me.Book[${QuickHeal}]}) {
        /call ConditionOK Heals QuickHeal
        /if (${Macro.Return}) /varset HealSpell ${QuickHeal}
    }
    /if (!${HealSpell.Length} && ${MainHeal.Length} && ${Me.Book[${MainHeal}]}) {
        /call ConditionOK Heals MainHeal
        /if (${Macro.Return}) /varset HealSpell ${MainHeal}
    }

    /if (!${HealSpell.Length}) {
        GZMDEBUG_HEAL No heal spells available
        /return
    }

    | Check mana
    /if (${Spell[${HealSpell}].Mana} > ${Me.CurrentMana}) {
        GZMDEBUG_HEAL Not enough mana for ${HealSpell}
        /return
    }

    | Make sure spell is memorized
    /if (!${Me.Gem[${HealSpell}]}) {
        /if (${InCombat}) {
            GZMDEBUG_HEAL ${HealSpell} not memmed, in combat - skipping
            /return
        }
        /call CastMem "${HealSpell}" Heal
    }

    | Cast using MQ2Cast with -targetid (no target switching!)
    /if (${Me.SpellReady[${HealSpell}]}) {
        GZMDEBUG_HEAL Casting ${HealSpell} on ${Spawn[${TargetID}].CleanName} (no target switch)
        /casting "${HealSpell}" -targetid|${TargetID}
        /delay 5 ${Me.Casting.ID}
        /delay 15s !${Me.Casting.ID}
        /varset HealsCast ${Math.Calc[${HealsCast}+1]}
    }

    /varset HealTimer 10
/return

| ============================================================================
| SUB: Emergency Heal - Fast heal on self when critically low
| Uses -targetid to avoid target switching
| ============================================================================
Sub DoEmergencyHeal
    /if (${Me.Casting.ID}) /return

    | Pure Tanks (WAR): Cannot cast heals
    /if (${IsPureTank}) /return

    | Lifetap Classes (SHD, NEC): Self-heal through DPS rotation, not emergency heals
    /if (${IsLifetapClass}) /return

    GZMDEBUG_HEAL EMERGENCY HEAL on self!

    /declare HealSpell string local

    | Determine best heal spell in priority order
    /if (${EmergencyHeal.Length} && ${Me.Book[${EmergencyHeal}]}) {
        /call ConditionOK Heals EmergencyHeal
        /if (${Macro.Return}) /varset HealSpell ${EmergencyHeal}
    }
    /if (!${HealSpell.Length} && ${QuickHeal.Length} && ${Me.Book[${QuickHeal}]}) {
        /call ConditionOK Heals QuickHeal
        /if (${Macro.Return}) /varset HealSpell ${QuickHeal}
    }
    /if (!${HealSpell.Length} && ${MainHeal.Length} && ${Me.Book[${MainHeal}]}) {
        /call ConditionOK Heals MainHeal
        /if (${Macro.Return}) /varset HealSpell ${MainHeal}
    }

    | No usable heal found
    /if (!${HealSpell.Length}) {
        GZMDEBUG_HEAL No emergency heal available
        /return
    }

    | Check mana
    /if (${Spell[${HealSpell}].Mana} > ${Me.CurrentMana}) /return

    | Cast on self using -targetid (no target switching!)
    /if (${Me.SpellReady[${HealSpell}]}) {
        GZMDEBUG_HEAL Emergency: ${HealSpell} (no target switch)
        /casting "${HealSpell}" -targetid|${Me.ID}
        /delay 5 ${Me.Casting.ID}
        /delay 15s !${Me.Casting.ID}
        /varset HealsCast ${Math.Calc[${HealsCast}+1]}
    }
/return

| ============================================================================
| SUB: Check OOG Health (Out of Group) via DanNet
| ============================================================================
Sub CheckOOGHealth
    /if (!${UseDanNet}) /return
    /if (!${OOGHealOn}) /return
    /if (!${DanNet.PeerCount}) /return

    /declare PeerCount int local ${DanNet.PeerCount}
    /declare i int local
    /declare PeerName string local
    /declare PeerID int local
    /declare PeerHP int local

    /for i 1 to ${PeerCount}
        /varset PeerName ${DanNet.Peers.Arg[${i},|]}
        /if (!${PeerName.Length}) /next i
        /if (${PeerName.Equal[${Me.CleanName}]}) /next i
        | Skip group members - handled by regular healing
        /if (${Group.Member[${PeerName}].ID}) /next i

        /varset PeerID ${Spawn[pc ${PeerName}].ID}
        /if (!${PeerID}) /next i
        /if (${Spawn[${PeerID}].Distance} > ${OOGRange}) /next i

        /varset PeerHP ${DanNet[${PeerName}].Observe[Me.PctHPs].Int}
        /if (!${PeerHP}) /next i

        /if (${PeerHP} <= ${OOGHealPct}) {
            GZMDEBUG_OOG Healing OOG peer ${PeerName} (${PeerHP}%)
            /call HealTarget ${PeerID}
            /return
        }
    /next i
/return

| ============================================================================
| SUB: Check For Combat
| ============================================================================
Sub CheckForCombat
    /varset MobCount 0

    | Clear invalid targets FIRST before any combat logic
    /call ClearInvalidTarget

    | Count mobs in camp
    /varset MobCount ${SpawnCount[npc targetable radius ${CampRadius} zradius ${MaxZRange}]}

    | Check if MA has a target
    /if (${Spawn[=${MainAssist}].ID}) {
        /varset MainAssistID ${Spawn[=${MainAssist}].ID}
    }

    | Get MA's target via DanNet
    /if (${UseDanNet} && ${DanNet[${MainAssist}].ObserveSet}) {
        | Query MA's target
    }

    | Check if we should be in combat
    /if (${MobCount} > 0 || ${Me.Combat}) {
        /if (!${InCombat}) {
            GZMDEBUG_COMBAT Entering combat - ${MobCount} mobs in camp
            /varset InCombat 1
            /varset CombatStart ${MacroQuest.Running}
            | Call combat entry hook
            /if (${Defined[OnCombatEnter]}) /call OnCombatEnter
        }
        /call DoCombat
        | Call combat loop hook each iteration
        /if (${Defined[OnCombatLoop]}) /call OnCombatLoop
    } else {
        /if (${InCombat}) {
            GZMDEBUG_COMBAT Exiting combat
            | Call combat exit hook
            /if (${Defined[OnCombatExit]}) /call OnCombatExit
            /call CombatReset
        }
    }
/return

| ============================================================================
| SUB: Do Combat
| ============================================================================
Sub DoCombat
    | Check backoff flag
    /if (${BackOffFlag}) {
        GZMDEBUG_COMBAT Backed off - waiting...
        /return
    }

    | Check for enrage
    /if (${Enraged}) {
        /if (${MeleeOn} && ${Me.Combat}) {
            /attack off
            GZMDEBUG_COMBAT Target ENRAGED - backing off
        }
        /return
    }

    | Get target
    /call AcquireTarget

    | Must have a target to do combat
    /if (!${Target.ID}) {
        /return
    }

    | For MA/Tank: Don't clear their target, just skip DPS if not valid NPC
    | Tank can target whatever they want, we just won't cast offensive spells
    /if (${IAmMA}) {
        | Only do combat if target is valid NPC
        /if (!${Target.Type.Equal[NPC]}) {
            GZMDEBUG_COMBAT DoCombat: MA target ${Target.Type} not NPC, skipping DPS (not clearing)
            /return
        }
        /if (${Target.PctHPs} <= 0 || ${Target.Type.Equal[Corpse]}) {
            /varset MyTargetID 0
            /return
        }
        /varset MyTargetID ${Target.ID}
    } else {
        | For assist roles: need valid MyTargetID
        /if (!${MyTargetID}) {
            /return
        }
        | Validate target matches MyTargetID and is NPC
        /if (${Target.ID} != ${MyTargetID}) {
            /target id ${MyTargetID}
            /delay 5 ${Target.ID} == ${MyTargetID}
        }
        /if (!${Target.Type.Equal[NPC]}) {
            GZMDEBUG_COMBAT DoCombat: Target not NPC, clearing for assist role
            /squelch /target clear
            /varset MyTargetID 0
            /return
        }
        /if (${Target.PctHPs} <= 0 || ${Target.Type.Equal[Corpse]}) {
            /varset MyTargetID 0
            /return
        }
    }

    | Do DPS
    /if (${DPSOn}) {
        /call DoDPS
    }

    | Do Melee
    /if (${MeleeOn} && ${Target.Distance} <= ${MeleeDistance}) {
        /call DoMelee
    }

    | Do Ranged
    /if (${RangedOn} && ${Target.Distance} > ${MeleeDistance}) {
        /call DoRanged
    }

    | Check burns
    /if (${BurnNow} || (${BurnAllNamed} && ${Target.Named})) {
        /call DoBurn
    }
    /if (${Defined[CustomCombatHook]}) /call CustomCombatHook
/return

| ============================================================================
| SUB: Acquire Target
| Only acquire valid NPC targets, clear invalid ones
| NOTE: MA/Tank manages their own targets - we just track MyTargetID
| ============================================================================
Sub AcquireTarget
    /declare NewTarget int local 0

    | If I AM the Main Assist/Tank, I pick my own targets - minimal interference
    /if (${IAmMA}) {
        | MA picks their own targets - only track if it's a VALID NPC target
        /if (${Target.ID} && ${Target.Type.Equal[NPC]} && ${Target.PctHPs} > 0) {
            /varset MyTargetID ${Target.ID}
        } else {
            | MA has no target or non-NPC target - just clear MyTargetID, don't touch their target
            /if (${MyTargetID} && (!${Spawn[${MyTargetID}].ID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]})) {
                /varset MyTargetID 0
            }
        }
        /return
    }

    | OUT OF COMBAT: Don't force targets - let user target freely
    | Only clear dead MyTargetID tracking
    /if (!${InCombat}) {
        /if (${MyTargetID} && (!${Spawn[${MyTargetID}].ID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]})) {
            /varset MyTargetID 0
        }
        /return
    }

    | IN COMBAT: Assist logic for assist roles
    | For assist roles: Check if current MyTargetID is still valid
    /if (${MyTargetID}) {
        | Check if spawn is dead or gone
        /if (!${Spawn[${MyTargetID}].ID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]}) {
            GZMDEBUG_COMBAT AcquireTarget: MyTargetID ${MyTargetID} is dead/gone, clearing
            /varset MyTargetID 0
        } else /if (!${Spawn[${MyTargetID}].Type.Equal[NPC]}) {
            | Target is no longer NPC (charmed, etc)
            GZMDEBUG_COMBAT AcquireTarget: MyTargetID ${MyTargetID} is not NPC anymore, clearing
            /varset MyTargetID 0
        }
    }

    | If assist is disabled, don't acquire targets from MA
    /if (!${AssistOn}) {
        /return
    }

    | If we have valid target, keep it
    /if (${MyTargetID} && ${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Type.Equal[NPC]}) {
        /if (${Spawn[${MyTargetID}].PctHPs} > 0) {
            | Ensure our actual target matches MyTargetID (only in combat)
            /if (${Target.ID} != ${MyTargetID}) {
                /target id ${MyTargetID}
                /delay 5 ${Target.ID} == ${MyTargetID}
            }
            /return
        }
    }

    | Clear dead/invalid MyTargetID
    /if (${MyTargetID}) {
        /varset MyTargetID 0
    }

    | Get MA's target via DanNet (preferred - no targeting needed)
    /if (${UseDanNet}) {
        /varset NewTarget ${DanNet[${MainAssist}].Observe[Target.ID].Int}
    } else /if (${Spawn[=${MainAssist}].ID}) {
        | Fallback: Target MA to get their target (only if no DanNet)
        /target id ${Spawn[=${MainAssist}].ID}
        /delay 3
        /varset NewTarget ${Me.TargetOfTarget.ID}
    }

    | Only accept NPC targets, reject all else
    /if (${NewTarget}) {
        | Must be NPC type
        /if (!${Spawn[${NewTarget}].Type.Equal[NPC]}) {
            GZMDEBUG_COMBAT AcquireTarget: MA target ${NewTarget} is ${Spawn[${NewTarget}].Type}, not NPC - ignoring
            /return
        }
        | Must be at assist HP
        /if (${Spawn[${NewTarget}].PctHPs} <= ${AssistAt}) {
            /varset MyTargetID ${NewTarget}
            /target id ${MyTargetID}
            /delay 5 ${Target.ID} == ${MyTargetID}
            GZMDEBUG_COMBAT AcquireTarget: New target: ${Target.CleanName} (${MyTargetID})
        }
    }
/return

| ============================================================================
| SUB: Do DPS (Spells/Abilities)
| Casts debuffs, dots, and nukes on current target
| Requires MyTargetID validation before DPS
| ============================================================================
Sub DoDPS
    | Must have validated MyTargetID
    /if (!${MyTargetID}) /return
    /if (!${Target.ID}) /return
    /if (${Me.Casting.ID}) /return
    | Must be NPC target - reject PC, Merc, Corpse, etc
    /if (!${Target.Type.Equal[NPC]}) /return
    | Must match our validated target ID
    /if (${Target.ID} != ${MyTargetID}) /return
    /if (${Target.PctHPs} < ${StopDPSPct}) /return

    GZMDEBUG_COMBAT DPS routine on ${Target.CleanName}

    | Cast debuffs first (slows, malo, etc)
    /if (${DebuffOn}) {
        /call CastDebuffs
    }

    | Cast DoTs if enabled and have mana
    /if (${DoTOn} && ${Me.PctMana} >= ${DoTManaPct}) {
        /call CastDoTs
    }

    | Cast nukes if enabled and have mana
    /if (${NukeOn} && ${Me.PctMana} >= ${NukeManaPct}) {
        /call CastNukes
    }
/return

| ============================================================================
| SUB: Cast Debuffs (Slow, Malo, Cripple, etc)
| Validates target before casting
| ============================================================================
Sub CastDebuffs
    /if (!${MyTargetID}) /return
    /if (!${Target.ID}) /return
    /if (${Me.Casting.ID}) /return
    /if (!${Target.Type.Equal[NPC]}) /return
    /if (${Target.ID} != ${MyTargetID}) /return

    | Check each debuff slot
    /if (${Debuff1.Length}) {
        /call ConditionOK Debuffs Debuff1
        /if (${Macro.Return} && !${Target.Buff[${Debuff1}].ID}) {
        /call CastSpellOnTarget "${Debuff1}"
        /if (${Macro.Return}) /return
    }
    }
    /if (${Debuff2.Length}) {
        /call ConditionOK Debuffs Debuff2
        /if (${Macro.Return} && !${Target.Buff[${Debuff2}].ID}) {
        /call CastSpellOnTarget "${Debuff2}"
        /if (${Macro.Return}) /return
    }
    }
    /if (${Debuff3.Length}) {
        /call ConditionOK Debuffs Debuff3
        /if (${Macro.Return} && !${Target.Buff[${Debuff3}].ID}) {
        /call CastSpellOnTarget "${Debuff3}"
    }
    }
/return

| ============================================================================
| SUB: Cast DoTs
| Validates target before casting
| ============================================================================
Sub CastDoTs
    /if (!${MyTargetID}) /return
    /if (!${Target.ID}) /return
    /if (${Me.Casting.ID}) /return
    /if (!${Target.Type.Equal[NPC]}) /return
    /if (${Target.ID} != ${MyTargetID}) /return

    | Check each DoT slot - only cast if not already on target
    /if (${DoT1.Length}) {
        /call ConditionOK DPS DoT1
        /if (${Macro.Return} && !${Target.Buff[${DoT1}].ID}) {
        /call CastSpellOnTarget "${DoT1}"
        /if (${Macro.Return}) {
            /varset DoTsCast ${Math.Calc[${DoTsCast}+1]}
            /return
        }
    }
    }
    /if (${DoT2.Length}) {
        /call ConditionOK DPS DoT2
        /if (${Macro.Return} && !${Target.Buff[${DoT2}].ID}) {
        /call CastSpellOnTarget "${DoT2}"
        /if (${Macro.Return}) {
            /varset DoTsCast ${Math.Calc[${DoTsCast}+1]}
            /return
        }
    }
    }
    /if (${DoT3.Length}) {
        /call ConditionOK DPS DoT3
        /if (${Macro.Return} && !${Target.Buff[${DoT3}].ID}) {
        /call CastSpellOnTarget "${DoT3}"
        /if (${Macro.Return}) {
            /varset DoTsCast ${Math.Calc[${DoTsCast}+1]}
            /return
        }
    }
    }
    /if (${DoT4.Length}) {
        /call ConditionOK DPS DoT4
        /if (${Macro.Return} && !${Target.Buff[${DoT4}].ID}) {
        /call CastSpellOnTarget "${DoT4}"
        /if (${Macro.Return}) {
            /varset DoTsCast ${Math.Calc[${DoTsCast}+1]}
            /return
        }
    }
    }
    /if (${DoT5.Length}) {
        /call ConditionOK DPS DoT5
        /if (${Macro.Return} && !${Target.Buff[${DoT5}].ID}) {
        /call CastSpellOnTarget "${DoT5}"
        /if (${Macro.Return}) {
            /varset DoTsCast ${Math.Calc[${DoTsCast}+1]}
        }
        }
    }
/return

| ============================================================================
| SUB: Cast Nukes
| Validates target before casting
| ============================================================================
Sub CastNukes
    /if (!${MyTargetID}) /return
    /if (!${Target.ID}) /return
    /if (${Me.Casting.ID}) /return
    /if (!${Target.Type.Equal[NPC]}) /return
    /if (${Target.ID} != ${MyTargetID}) /return

    | Cast first available nuke
    /if (${Nuke1.Length}) {
        /call ConditionOK DPS Nuke1
        /if (${Macro.Return}) {
        /call CastSpellOnTarget "${Nuke1}"
        /if (${Macro.Return}) {
            /varset NukesCast ${Math.Calc[${NukesCast}+1]}
            /return
        }
        }
    }
    /if (${Nuke2.Length}) {
        /call ConditionOK DPS Nuke2
        /if (${Macro.Return}) {
        /call CastSpellOnTarget "${Nuke2}"
        /if (${Macro.Return}) {
            /varset NukesCast ${Math.Calc[${NukesCast}+1]}
            /return
        }
        }
    }
    /if (${Nuke3.Length}) {
        /call ConditionOK DPS Nuke3
        /if (${Macro.Return}) {
        /call CastSpellOnTarget "${Nuke3}"
        /if (${Macro.Return}) {
            /varset NukesCast ${Math.Calc[${NukesCast}+1]}
        }
        }
    }
/return

| ============================================================================
| SUB: ValidateTarget
| Validates that current target is a valid NPC combat target
| Returns: 1 = valid target, 0 = invalid target
| NOTE: For MA/Tank, returns validity but NEVER clears their target
| ============================================================================
Sub ValidateTarget
    /declare MobID int local 0
    /declare MobType string local

    | If we have MyTargetID, use that spawn's info
    /if (${MyTargetID}) {
        /varset MobID ${Spawn[${MyTargetID}].ID}
        /varset MobType ${Spawn[${MyTargetID}].Type}
    } else /if (${Target.ID}) {
        /varset MobID ${Target.ID}
        /varset MobType ${Target.Type}
    }

    | No target at all
    /if (!${MobID}) {
        /varset MyTargetID 0
        /return 0
    }

    | Check if target is a corpse (dead)
    /if (${MobType.Equal[Corpse]}) {
        GZMDEBUG_COMBAT ValidateTarget: Target is corpse
        /varset MyTargetID 0
        | Only clear target for assist roles, not MA/Tank
        /if (!${IAmMA}) /squelch /target clear
        /return 0
    }

    | Reject bad target types: PC, Mercenary, PC pets, auras, banners, etc
    /if (${Select[${MobType},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,TRIGGER,TRAP,TIMER,MOUNT,Mercenary,PC]}) {
        GZMDEBUG_COMBAT ValidateTarget: Bad target type ${MobType}
        /varset MyTargetID 0
        | Only clear target for assist roles, not MA/Tank
        /if (!${IAmMA}) /squelch /target clear
        /return 0
    }

    | Check if it's a PC pet (not NPC pet)
    /if (${MobType.Equal[Pet]} && ${Spawn[${MobID}].Master.Type.Equal[PC]}) {
        GZMDEBUG_COMBAT ValidateTarget: Target is PC pet
        /varset MyTargetID 0
        | Only clear target for assist roles, not MA/Tank
        /if (!${IAmMA}) /squelch /target clear
        /return 0
    }

    | Check if target is charmed
    /if (${Target.ID}==${MobID} && ${Target.Charmed.ID}) {
        GZMDEBUG_COMBAT ValidateTarget: Target is charmed
        /varset MyTargetID 0
        | Only clear target for assist roles, not MA/Tank
        /if (!${IAmMA}) /squelch /target clear
        /return 0
    }

    | Target is valid NPC or NPC pet
    /if (${MobType.Equal[NPC]} || (${MobType.Equal[Pet]} && ${Spawn[${MobID}].Master.Type.Equal[NPC]})) {
        /return 1
    }

    | Default: invalid target
    GZMDEBUG_COMBAT ValidateTarget: Unknown type ${MobType}, clearing
    /varset MyTargetID 0
    | Only clear target for assist roles, not MA/Tank
    /if (!${IAmMA}) /squelch /target clear
/return 0

| ============================================================================
| SUB: ClearInvalidTarget
| Called from CheckForCombat to clear invalid targets early
| NOTE: Does NOT clear targets for MA/Tank - they pick their own targets
| NOTE: Only clears targets during ACTIVE COMBAT - let users target freely otherwise
| ============================================================================
Sub ClearInvalidTarget
    | MA/Tank picks their own targets - don't mess with their targeting
    /if (${IAmMA}) {
        | Just clear MyTargetID if our tracked target is dead/gone
        /if (${MyTargetID} && (!${Spawn[${MyTargetID}].ID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]})) {
            GZMDEBUG_COMBAT ClearInvalidTarget: MA's MyTargetID ${MyTargetID} is dead/gone
            /varset MyTargetID 0
        }
        /return 0
    }

    | ONLY clear targets during active combat - let users target freely out of combat
    | This allows buffing, healing, inspecting other players, etc.
    /if (!${InCombat}) {
        | Out of combat - just clear dead MyTargetID, don't touch actual target
        /if (${MyTargetID} && (!${Spawn[${MyTargetID}].ID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]})) {
            /varset MyTargetID 0
        }
        /return 0
    }

    | IN COMBAT: Clear invalid targets for assist roles
    | For assist roles: If current target is not NPC but we think we have a target, validate it
    /if (${Target.Type.NotEqual[NPC]} && ${MyTargetID}) {
        | Check if MyTargetID spawn is dead or gone
        /if (!${Spawn[${MyTargetID}].ID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]}) {
            GZMDEBUG_COMBAT ClearInvalidTarget: MyTargetID ${MyTargetID} is dead/gone
            /varset MyTargetID 0
        }
        /if (!${IAmMA}) /squelch /target clear
        /return 1
    }

    | For assist roles IN COMBAT: If target is PC/Mercenary/PC-Pet, clear it
    /if (${Target.ID}) {
        /if (${Target.Type.Equal[PC]} || ${Target.Type.Equal[Mercenary]}) {
            GZMDEBUG_COMBAT ClearInvalidTarget: Target is PC/Merc, clearing
            /if (!${IAmMA}) /squelch /target clear
            /varset MyTargetID 0
            /return 1
        }
        /if (${Target.Type.Equal[Pet]} && ${Target.Master.Type.Equal[PC]}) {
            GZMDEBUG_COMBAT ClearInvalidTarget: Target is PC pet, clearing
            /if (!${IAmMA}) /squelch /target clear
            /varset MyTargetID 0
            /return 1
        }
    }
/return 0

| ============================================================================
| SUB: CastMemSpell - Memorize a spell in a gem slot
| ============================================================================
Sub CastMemSpell(string SpellToMem, int gemNum, int ForceIt, string sentFrom)
    GZMDEBUG_CAST CastMemSpell Enter: ${SpellToMem} gem ${gemNum}
    /if (${Int[${SpellToMem.Length}]}==0 || ${SpellToMem.Equal[null]} || ${gemNum}==0) /return

    | Already memorized in requested gem?
    /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && !${ForceIt}) /return

    | Handle cursor items
    /if (${Cursor.ID} && ${Cursor.NoRent}) {
        /autoinventory
        /delay 10
    }

    | Force unmem if spell already in different gem
    /if (${ForceIt}) {
        /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && ${gemNum}!=${ForceIt}) {
            /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${ForceIt}-1]}]} rightmouseup
            /delay 20 ${Int[${Me.Gem[${gemNum}].ID}]}==0
        }
    }

    | Check if spell is in spellbook
    /if (${Me.Book[${SpellToMem}]}) {
        /if (!${Cursor.ID}) {
            | Unmem existing spell from target gem
            /if (${Int[${Me.Gem[${gemNum}].ID}]}>0) {
                /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${gemNum}-1]}]} rightmouseup
                /delay 20 ${Int[${Me.Gem[${gemNum}].ID}]}==0
            }
            | Memorize the spell if not already in that gem
            /if (!${Int[${Me.Gem[${gemNum}].Name.Length}]} || ${Me.Gem[${gemNum}].Name.NotEqual[${SpellToMem}]}) {
                | Stop moving during memorization
                /while (${Me.Moving}) {
                    /delay 5
                }
                /echo [GronnzMaster] Memorizing ${SpellToMem} in gem ${gemNum}
                | Pause stick if active
                /if (${Stick.Active}) {
                    /stick pause
                    /memspell ${gemNum} "${SpellToMem}"
                    /delay 150 ${Me.Gem[${gemNum}].Name.Equal[${SpellToMem}]}
                    /stick unpause
                } else {
                    /memspell ${gemNum} "${SpellToMem}"
                    /delay 150 ${Me.Gem[${gemNum}].Name.Equal[${SpellToMem}]}
                }
            }
        } else {
            /echo [GronnzMaster] Cannot mem spell with items on cursor. Drop to inventory first.
        }
    } else {
        /echo [GronnzMaster] Spell ${SpellToMem} not found in spellbook.
    }

    | Close spellbook if stuck open
    /if (${Window[SpellBookWnd].Open}) /windowstate spellbookwnd close
    GZMDEBUG_CAST CastMemSpell Leave: ${Me.Gem[${gemNum}].Name}
/return

| ============================================================================
| SUB: CastMem - Wrapper to memorize spell with combat checks
| ============================================================================
Sub CastMem(string WhatMemSpell, string sentFrom)
    GZMDEBUG_CAST CastMem Enter: ${WhatMemSpell}
    /declare WaitTimerCM timer local 0
    /declare UseGem int local 0

    | Already memorized? No need to do anything
    /if (${Me.Gem[${WhatMemSpell}]}) {
        GZMDEBUG_CAST ${WhatMemSpell} already memorized in gem ${Me.Gem[${WhatMemSpell}]}
        /return 1
    }

    | Don't mem while casting or moving
    /if (${Me.Casting.ID} || ${Me.Moving}) /return notready

    | Don't mem while invisible (unless healing)
    /if (${Me.Invis} && !${Select[${sentFrom},Heal,SingleHeal,GroupHeal]}) {
        /return notready
    }

    | Prevent tanks trying to mem during combat
    /if (${InCombat} && ${Select[${Role},Tank,MA,MT]}) {
        /echo [GronnzMaster] Cannot mem spell during combat: ${WhatMemSpell}
        /return notready
    }

    | Handle cursor items
    /if (${Cursor.ID}) {
        /if (${Cursor.NoRent}) {
            /autoinventory
            /delay 10
        }
    }

    | Check mana cost
    /if (${Spell[${WhatMemSpell}].Mana}>${Me.CurrentMana}) /return notready

    | Find best gem to use - check gems 6, 7, 8 for empty slot first
    /if (!${Me.Gem[6].ID}) {
        /varset UseGem 6
    } else /if (!${Me.Gem[7].ID}) {
        /varset UseGem 7
    } else /if (!${Me.Gem[8].ID}) {
        /varset UseGem 8
    } else {
        | All gems full - use gem 8 as default overwrite
        /varset UseGem 8
    }

    GZMDEBUG_CAST Memorizing ${WhatMemSpell} in gem ${UseGem}

    | Remember what we're memming for potential re-mem later
    /varset ReMemWaitShort ${WhatMemSpell}
    /varset DontMoveMe 1
    /call CastMemSpell "${WhatMemSpell}" ${UseGem} 0 CastMem
    /varset DontMoveMe 0

    | Wait for spell to be ready after memming
    /if (${Me.Gem[${WhatMemSpell}]}) {
        /varset WaitTimerCM 350
        /while (!${Me.SpellReady[${WhatMemSpell}]} && ${WaitTimerCM}) {
            /delay 5
            | Abort if combat starts during buff memming
            /if (${Select[${sentFrom},buffs,Buffs,buffonce,BuffOnce]} && ${InCombat}) {
                /return notready
            }
        }
    }

    /if (!${Me.Gem[${WhatMemSpell}]}) /return notready
    GZMDEBUG_CAST CastMem Leave
/return 1

| ============================================================================
| SUB: Cast Spell On Target
| Returns 1 if cast successful, 0 if not
| Handles AA, Item, Disc, and Spell casting with auto-memorization
| ============================================================================
Sub CastSpellOnTarget(string SpellName)
    | Skip empty spell names
    /if (!${SpellName.Length}) /return 0

    /declare ReadyToCast int local 0
    /declare MemReturn string local null

    | Determine what type of ability this is and if it's ready
    | 1=Item, 2=AA, 3=Disc, 4=Skill, 5=Spell Ready, 6=Command, 7=Spell needs mem
    /if (${Me.AltAbility[${SpellName}]} || ${FindItem[=${SpellName}].ID} || ${Me.CombatAbility[${SpellName}]} || ${Me.Skill[${SpellName}]} || ${Me.Book[${SpellName}]}) {
        /varset ReadyToCast ${Select[TRUE,${Me.ItemReady[=${SpellName}]},${Me.AltAbilityReady[${SpellName}]},${Me.CombatAbilityReady[${SpellName}]},${If[${Me.AbilityReady[${SpellName}]} && ${Me.Skill[${SpellName}]},TRUE,FALSE]},${Me.SpellReady[${SpellName}]}]}

        | Spell in book but not memmed?
        /if (${ReadyToCast}==0 && ${Me.Book[${SpellName}]}) {
            /if (!${FindItem[=${SpellName}].ID} && !${Me.Gem[${SpellName}]} && !${Me.AltAbility[${SpellName}]}) {
                /varset ReadyToCast 7
            }
        }
    } else {
        GZMDEBUG_CAST ${SpellName} not found (not AA, Item, Disc, Skill, or Spell)
        /return 0
    }

    | Not ready to cast
    /if (!${ReadyToCast}) {
        GZMDEBUG_CAST ${SpellName} not ready (ReadyToCast=0)
        /return 0
    }

    | Already casting
    /if (${Me.Casting.ID} && ${Window[CastingWindow].Open}) /return 0

    GZMDEBUG_CAST CastSpellOnTarget: ${SpellName} ReadyToCast=${ReadyToCast}

    | Cast based on type
    /if (${ReadyToCast}==1 && ${Me.ItemReady[=${SpellName}]} && ${FindItem[=${SpellName}].ID}) {
        | Item click
        GZMDEBUG_CAST Casting item: ${SpellName}
        /useitem "${SpellName}"
        /delay 5 ${Me.Casting.ID}
        /delay 15s !${Me.Casting.ID}
        /return 1

    } else /if (${ReadyToCast}==2 && ${Me.AltAbilityReady[${SpellName}]} && !${FindItem[=${SpellName}].ID}) {
        | AA
        GZMDEBUG_CAST Using AA: ${SpellName}
        /alt act ${Me.AltAbility[${SpellName}].ID}
        /delay 5 ${Me.Casting.ID}
        /delay 15s !${Me.Casting.ID}
        /return 1

    } else /if (${ReadyToCast}==3 && ${Me.CombatAbilityReady[${SpellName}]}) {
        | Combat Ability / Disc
        GZMDEBUG_CAST Using Disc: ${SpellName}
        /disc "${SpellName}"
        /delay 5
        /return 1

    } else /if (${ReadyToCast}==4 && ${Me.AbilityReady[${SpellName}]}) {
        | Skill/Ability
        GZMDEBUG_CAST Using Skill: ${SpellName}
        /doability "${SpellName}"
        /delay 5
        /return 1

    } else /if (${ReadyToCast}==5) {
        | Spell already memorized and ready
        /if (${Spell[${SpellName}].Mana}<${Me.CurrentMana}) {
            /if (${Me.SpellReady[${SpellName}]} && ${Me.Book[${SpellName}]}) {
                GZMDEBUG_CAST Casting spell: ${SpellName}
                /cast "${SpellName}"
                /delay 5 ${Me.Casting.ID}
                /delay 15s !${Me.Casting.ID}
                /return 1
            }
        } else {
            GZMDEBUG_CAST Not enough mana for ${SpellName}
            /return 0
        }

    } else /if (${ReadyToCast}==7) {
        | Spell needs memorization
        /if (!${InCombat}) {
            /if (${Spell[${SpellName}].Mana}<${Me.CurrentMana}) {
                /call CastMem "${SpellName}" DPS
                /varset MemReturn ${Macro.Return}
                /if (${Macro.Return.NotEqual[notready]} && ${Me.Gem[${SpellName}]}!=0) {
                    GZMDEBUG_CAST Casting newly memmed spell: ${SpellName}
                    /cast "${SpellName}"
                    /delay 5 ${Me.Casting.ID}
                    /delay 15s !${Me.Casting.ID}
                    /return 1
                }
            } else {
                GZMDEBUG_CAST Not enough mana for ${SpellName}
                /return 0
            }
        } else {
            GZMDEBUG_CAST ${SpellName} not memmed, in combat - skipping
            /return 0
        }
    }
/return 0

| ============================================================================
| SUB: Do Melee
| ============================================================================
Sub DoMelee
    | Stick to target
    /if (${UseNav} && ${Plugin[MQ2Nav].Name.Length} && ${Target.Distance} > ${StickDistance}) {
        /if (!${Stick.Active}) {
            /squelch /stick ${StickDistance} ${StickPoint} ${StickMod}
        }
    } else /if (!${Stick.Active} && ${Target.Distance} <= ${MeleeDistance}) {
        /squelch /stick ${StickDistance} ${StickPoint} ${StickMod}
    }

    | Attack
    /if (!${Me.Combat} && ${Target.Distance} <= ${MeleeDistance}) {
        /attack on
    }
/return

| ============================================================================
| SUB: Do Ranged
| ============================================================================
Sub DoRanged
    /if (${AutoFireOn} && !${Me.AutoFire}) {
        /autofire on
    }
/return

| ============================================================================
| SUB: Do Burn - Activate burn abilities/AAs
| ============================================================================
Sub DoBurn
    /if (!${BurnNow}) /return

    GZMDEBUG_COMBAT BURN activated!

    | Use burn abilities - check each slot
    /if (${Burn1.Length}) {
        /call UseBurnAbility "${Burn1}" "${Burn1Type}"
    }
    /if (${Burn2.Length}) {
        /call UseBurnAbility "${Burn2}" "${Burn2Type}"
    }
    /if (${Burn3.Length}) {
        /call UseBurnAbility "${Burn3}" "${Burn3Type}"
    }

    | Reset burn flag after using abilities
    /varset BurnNow 0
/return

| ============================================================================
| SUB: Use Burn Ability
| Types: AA, Disc, Item, Spell
| ============================================================================
Sub UseBurnAbility(string AbilityName, string AbilityType)
    /if (!${AbilityName.Length}) /return

    GZMDEBUG_COMBAT Using burn: ${AbilityName} (${AbilityType})

    /if (${AbilityType.Equal[AA]}) {
        /if (${Me.AltAbilityReady[${AbilityName}]}) {
            /alt activate ${Me.AltAbility[${AbilityName}].ID}
            /delay 5
        }
    } else /if (${AbilityType.Equal[Disc]}) {
        /if (${Me.CombatAbilityReady[${AbilityName}]}) {
            /disc ${AbilityName}
            /delay 5
        }
    } else /if (${AbilityType.Equal[Item]}) {
        /if (${FindItem[${AbilityName}].TimerReady} == 0) {
            /useitem "${AbilityName}"
            /delay 5
        }
    } else /if (${AbilityType.Equal[Spell]}) {
        /call CastSpellOnTarget "${AbilityName}"
    }
/return

| ============================================================================
| SUB: Class Specific Combat Helpers
| ============================================================================
Sub ClassSpecificCombat
    /if (!${Target.ID}) /return

    /if (${Me.Class.ShortName.Equal[WAR]} || ${Me.Class.ShortName.Equal[PAL]} || ${Me.Class.ShortName.Equal[SHD]}) {
        /call TankCombatTools
    } else /if (${Me.Class.ShortName.Equal[ROG]}) {
        /call RogueCombatTools
    } else /if (${Me.Class.ShortName.Equal[MNK]}) {
        /call MonkCombatTools
    } else /if (${Me.Class.ShortName.Equal[BER]}) {
        /call BerserkerCombatTools
    } else /if (${Me.Class.ShortName.Equal[RNG]}) {
        /call RangerCombatTools
    }
/return

Sub TankCombatTools
    /if (${Me.AbilityReady[Taunt]}) /doability Taunt
    /if (${Me.AbilityReady[Bash]} && ${Target.Distance} <= ${MeleeDistance}) /doability Bash
    /if (${Me.AbilityReady[Kick]} && ${Target.Distance} <= ${MeleeDistance}) /doability Kick
/return

Sub RogueCombatTools
    /if (${Me.AbilityReady[Backstab]} && ${Target.Distance} <= ${MeleeDistance}) {
        /doability Backstab
    }
/return

Sub MonkCombatTools
    /if (${Me.AbilityReady["Flying Kick"]} && ${Target.Distance} <= ${MeleeDistance}) {
        /doability "Flying Kick"
    } else /if (${Me.AbilityReady[Kick]} && ${Target.Distance} <= ${MeleeDistance}) {
        /doability Kick
    }
/return

Sub BerserkerCombatTools
    /if (${Me.AbilityReady[Frenzy]} && ${Target.Distance} <= ${MeleeDistance}) {
        /doability Frenzy
    }
/return

Sub RangerCombatTools
    /if (${AutoFireOn} && !${Me.AutoFire}) {
        /autofire on
    } else /if (!${AutoFireOn} && ${Me.AutoFire}) {
        /autofire off
    }
/return

| ============================================================================
| SUB: Combat Reset
| ============================================================================
Sub CombatReset
    | -------------------------------------------------------------------------
    | ENHANCED COMBAT RESET
    | Full state cleanup, pet control, MQ2Melee reset, camp return
    | -------------------------------------------------------------------------

    | Set state to IDLE
    /if (${Defined[SetState]}) /call SetState IDLE

    | Clear combat targeting
    /varset InCombat 0
    /varset MyTargetID 0
    /varset CombatStart 0
    /varset Enraged 0
    /varset BurnNow 0
    /if (${Defined[GMCombatTarget]}) /varset GMCombatTarget 0

    | Stop attacking
    /if (${Me.Combat}) /attack off

    | Clear target
    /squelch /target clear

    | Reset MQ2Melee
    /squelch /melee plugin=0

    | Stop movement (stick/nav)
    /if (${Stick.Active}) /squelch /stick off
    /squelch /nav stop

    | Clear stuck tracking
    /if (${Defined[StuckCount]}) /varset StuckCount 0

    | Pet control - back off and follow
    /if (${Me.Pet.ID}) {
        /pet back off
        /pet follow
    }

    | Flush combat events to prevent stale processing
    /doevents flush ImHit
    /doevents flush GotHit
    /doevents flush Enraged
    /doevents flush NotEnraged

    | Reset combat-related timers
    /if (${Defined[ResetCombatTimers]}) /call ResetCombatTimers

    | Reset debuff tracking
    /if (${Defined[ResetDebuffTracking]}) /call ResetDebuffTracking

    | Return to camp if active
    /if (${ReturnToCamp} && ${CampXLoc} && ${CampYLoc}) {
        /declare distToCamp float local ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}
        /if (${distToCamp}>${CampRadius}) {
            GZMDEBUG_COMBAT Returning to camp (${Int[${distToCamp}]} away)
            /nav loc ${CampYLoc} ${CampXLoc} ${CampZLoc}
            /delay 3s !${Navigation.Active}
        }
    }

    | Enable sit/med timer
    /if (${Defined[SitCheckTimer]}) /varset SitCheckTimer 50

    GZMDEBUG_COMBAT Combat reset complete
/return

| ============================================================================
| SUB: Check Buffs
| ============================================================================
Sub CheckBuffs
    /if (${BuffTimer}) /return
    /if (${Me.Moving}) /return
    /if (${Me.Casting.ID}) /return
    | MA/Tank should focus on combat, not buffing - others can buff anytime (uses -targetid)
    /if (${InCombat} && ${IAmMA}) /return

    GZMDEBUG_BUFF Checking buffs...

    | Check self buffs
    /call CheckSelfBuffs

    | Check group buffs
    /call CheckGroupBuffs

    | Check pet buffs
    /if (${Me.Pet.ID}) {
        /call CheckPetBuffs
    }

    | Check DanNet buffs - buff ALL DanNet peers (not just group) with GroupBuffs
    /if (${DanNetBuffOn}) {
        /call CheckDanNetBuffs
    }

    | Check OOG buffs - use specific OOGBuffs from [OOGBuffs] section
    /if (${OOGBuffOn}) {
        /call CheckOOGBuffs
    }

    /varset BuffTimer 50
    /if (${Defined[CustomBuffHook]}) /call CustomBuffHook
/return

| ============================================================================
| SUB: Check Self Buffs
| ============================================================================
Sub CheckSelfBuffs
    | MA/Tank skip self buffs in combat - others can self-buff anytime
    /if (${InCombat} && ${IAmMA}) /return
    GZMDEBUG_BUFF Checking self buffs

    | Check each self buff slot - use CastSelfBuff (no targeting needed)
    /if (${SelfBuff1.Length}) {
        /call ConditionOK Buffs SelfBuff1
        /if (${Macro.Return}) /call CastSelfBuff "${SelfBuff1}"
    }
    /if (${SelfBuff2.Length}) {
        /call ConditionOK Buffs SelfBuff2
        /if (${Macro.Return}) /call CastSelfBuff "${SelfBuff2}"
    }
    /if (${SelfBuff3.Length}) {
        /call ConditionOK Buffs SelfBuff3
        /if (${Macro.Return}) /call CastSelfBuff "${SelfBuff3}"
    }
    /if (${SelfBuff4.Length}) {
        /call ConditionOK Buffs SelfBuff4
        /if (${Macro.Return}) /call CastSelfBuff "${SelfBuff4}"
    }
    /if (${SelfBuff5.Length}) {
        /call ConditionOK Buffs SelfBuff5
        /if (${Macro.Return}) /call CastSelfBuff "${SelfBuff5}"
    }
/return

| ============================================================================
| SUB: Cast Self Buff (NO TARGETING AT ALL)
| Self buffs don't need any targeting - just /cast
| ============================================================================
Sub CastSelfBuff(string SpellName)
    /if (!${SpellName.Length}) /return
    | MA/Tank skip self buffs in combat - others can self-buff anytime
    /if (${InCombat} && ${IAmMA}) /return

    | Check if we have the spell
    /if (!${Me.Book[${SpellName}]}) /return

    | Check if we already have the buff
    /if (${Me.Buff[${SpellName}].ID}) /return
    /if (${Me.Song[${SpellName}].ID}) /return

    | Check mana
    /if (${Me.PctMana} < 20) /return

    | Check if casting
    /if (${Me.Casting.ID}) /return

    | Check buff timer
    /if (${BuffTimer}) /return

    | Check if spell ready
    /if (!${Me.SpellReady[${SpellName}]}) /return

    GZMDEBUG_BUFF Casting self buff: ${SpellName}

    | Just /cast - self buffs don't need targeting!
    /cast "${SpellName}"
    /delay 5 ${Me.Casting.ID}
    /delay 15s !${Me.Casting.ID}

    /varset BuffsCast ${Math.Calc[${BuffsCast}+1]}
    /varset BuffTimer 50
/return

| ============================================================================
| SUB: Check Group Buffs
| ============================================================================
Sub CheckGroupBuffs
    | MA/Tank skip group buffs in combat - buff classes can buff anytime (uses -targetid)
    /if (${InCombat} && ${IAmMA}) /return
    GZMDEBUG_BUFF Checking group buffs

    /declare i int local
    /declare memberID int local
    /declare memberClass string local

    | Loop through group members
    /for i 0 to ${Group.Members}
        /if (${i} == 0) {
            /varset memberID ${Me.ID}
            /varset memberClass ${Me.Class.ShortName}
        } else {
            /if (!${Group.Member[${i}].ID}) /goto :skipMember
            /varset memberID ${Group.Member[${i}].ID}
            /varset memberClass ${Group.Member[${i}].Class.ShortName}
        }

        | Check distance
        /if (${Spawn[id ${memberID}].Distance} > 100) /goto :skipMember

        | Check each group buff
        /if (${GroupBuff1.Length}) {
            /call ConditionOK Buffs GroupBuff1
            /if (${Macro.Return} && (${GroupBuff1Class.Equal[All]} || ${GroupBuff1Class.Find[${memberClass}]})) {
                /call CheckAndCastBuff "${GroupBuff1}" "${memberID}"
            }
        }
        /if (${GroupBuff2.Length}) {
            /call ConditionOK Buffs GroupBuff2
            /if (${Macro.Return} && (${GroupBuff2Class.Equal[All]} || ${GroupBuff2Class.Find[${memberClass}]})) {
                /call CheckAndCastBuff "${GroupBuff2}" "${memberID}"
            }
        }
        /if (${GroupBuff3.Length}) {
            /call ConditionOK Buffs GroupBuff3
            /if (${Macro.Return} && (${GroupBuff3Class.Equal[All]} || ${GroupBuff3Class.Find[${memberClass}]})) {
                /call CheckAndCastBuff "${GroupBuff3}" "${memberID}"
            }
        }
        /if (${GroupBuff4.Length}) {
            /call ConditionOK Buffs GroupBuff4
            /if (${Macro.Return} && (${GroupBuff4Class.Equal[All]} || ${GroupBuff4Class.Find[${memberClass}]})) {
                /call CheckAndCastBuff "${GroupBuff4}" "${memberID}"
            }
        }
        /if (${GroupBuff5.Length}) {
            /call ConditionOK Buffs GroupBuff5
            /if (${Macro.Return} && (${GroupBuff5Class.Equal[All]} || ${GroupBuff5Class.Find[${memberClass}]})) {
                /call CheckAndCastBuff "${GroupBuff5}" "${memberID}"
            }
        }

        :skipMember
    /next i
/return

| ============================================================================
| SUB: Check Pet Buffs
| ============================================================================
Sub CheckPetBuffs
    GZMDEBUG_PET Checking pet buffs
    /if (!${Me.Pet.ID}) /return

    /if (${PetBuff1.Length}) {
        /call ConditionOK Buffs PetBuff1
        /if (${Macro.Return}) /call CheckAndCastBuff "${PetBuff1}" "${Me.Pet.ID}"
    }
    /if (${PetBuff2.Length}) {
        /call ConditionOK Buffs PetBuff2
        /if (${Macro.Return}) /call CheckAndCastBuff "${PetBuff2}" "${Me.Pet.ID}"
    }
    /if (${PetBuff3.Length}) {
        /call ConditionOK Buffs PetBuff3
        /if (${Macro.Return}) /call CheckAndCastBuff "${PetBuff3}" "${Me.Pet.ID}"
    }
/return

| ============================================================================
| SUB: Check DanNet Buffs
| Applies GroupBuffs to ALL DanNet peers not in current group
| This enables buffing all your logged-in characters regardless of group
| ============================================================================
Sub CheckDanNetBuffs
    | MA/Tank skip DanNet buffs in combat - buff classes can buff anytime (uses -targetid)
    /if (${InCombat} && ${IAmMA}) /return
    /if (!${UseDanNet}) /return
    /if (!${Plugin[MQ2DanNet].Name.Length}) /return
    /if (!${DanNet.PeerCount}) /return

    GZMDEBUG_DANNET Checking DanNet buffs for all peers (${DanNet.PeerCount} total)

    /declare i int local
    /declare PeerName string local
    /declare PeerID int local
    /declare PeerClass string local
    /declare PeerCount int local ${DanNet.PeerCount}

    | Iterate through all DanNet peers using pipe delimiter
    /for i 1 to ${PeerCount}
        /varset PeerName ${DanNet.Peers.Arg[${i},|]}

        | Skip empty or self
        /if (!${PeerName.Length}) /goto :nextDanNetPeer
        /if (${PeerName.Equal[${Me.Name}]}) /goto :nextDanNetPeer

        | Skip if peer is in our group (CheckGroupBuffs handles those)
        /if (${Group.Member[${PeerName}].ID}) /goto :nextDanNetPeer

        | Check if peer is in our zone (spawn exists)
        /varset PeerID ${Spawn[pc ${PeerName}].ID}
        /if (!${PeerID}) {
            GZMDEBUG_DANNET ${PeerName} not in zone, skipping
            /goto :nextDanNetPeer
        }

        | Check range
        /if (${Spawn[id ${PeerID}].Distance} > ${OOGRange}) {
            GZMDEBUG_DANNET ${PeerName} out of range (${Spawn[id ${PeerID}].Distance})
            /goto :nextDanNetPeer
        }

        | Get peer's class for class filtering
        /varset PeerClass ${Spawn[id ${PeerID}].Class.ShortName}

        GZMDEBUG_DANNET Buffing DanNet peer ${PeerName} (${PeerClass}) with GroupBuffs

        | Apply GroupBuffs to this DanNet peer (not in group)
        /if (${GroupBuff1.Length}) {
            /call ConditionOK Buffs GroupBuff1
            /if (${Macro.Return} && (${GroupBuff1Class.Equal[All]} || ${GroupBuff1Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${GroupBuff1}" "${PeerID}" "${PeerName}"
            }
        }
        /if (${GroupBuff2.Length}) {
            /call ConditionOK Buffs GroupBuff2
            /if (${Macro.Return} && (${GroupBuff2Class.Equal[All]} || ${GroupBuff2Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${GroupBuff2}" "${PeerID}" "${PeerName}"
            }
        }
        /if (${GroupBuff3.Length}) {
            /call ConditionOK Buffs GroupBuff3
            /if (${Macro.Return} && (${GroupBuff3Class.Equal[All]} || ${GroupBuff3Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${GroupBuff3}" "${PeerID}" "${PeerName}"
            }
        }
        /if (${GroupBuff4.Length}) {
            /call ConditionOK Buffs GroupBuff4
            /if (${Macro.Return} && (${GroupBuff4Class.Equal[All]} || ${GroupBuff4Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${GroupBuff4}" "${PeerID}" "${PeerName}"
            }
        }
        /if (${GroupBuff5.Length}) {
            /call ConditionOK Buffs GroupBuff5
            /if (${Macro.Return} && (${GroupBuff5Class.Equal[All]} || ${GroupBuff5Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${GroupBuff5}" "${PeerID}" "${PeerName}"
            }
        }

        :nextDanNetPeer
    /next i
/return

| ============================================================================
| SUB: Check OOG Buffs (Out of Group)
| Uses DanNet to find all logged-in characters across the network
| Buffs characters not in current group who are in range
| ============================================================================
Sub CheckOOGBuffs
    | MA/Tank skip OOG buffs in combat - buff classes can buff anytime (uses -targetid)
    /if (${InCombat} && ${IAmMA}) /return
    /if (!${UseDanNet}) /return
    /if (!${Plugin[MQ2DanNet].Name.Length}) /return
    /if (!${DanNet.PeerCount}) /return

    GZMDEBUG_OOG Checking OOG buffs via DanNet (${DanNet.PeerCount} peers)

    /declare i int local
    /declare PeerName string local
    /declare PeerID int local
    /declare PeerClass string local
    /declare PeerCount int local ${DanNet.PeerCount}

    | Iterate through all DanNet peers using pipe delimiter
    /for i 1 to ${PeerCount}
        /varset PeerName ${DanNet.Peers.Arg[${i},|]}

        | Skip empty or self
        /if (!${PeerName.Length}) /goto :nextPeer
        /if (${PeerName.Equal[${Me.Name}]}) /goto :nextPeer

        | Skip if peer is in our group (use GroupBuffs for those)
        /if (${Group.Member[${PeerName}].ID}) /goto :nextPeer

        | Check if peer is in our zone (spawn exists)
        /varset PeerID ${Spawn[pc ${PeerName}].ID}
        /if (!${PeerID}) {
            GZMDEBUG_OOG ${PeerName} not in zone, skipping
            /goto :nextPeer
        }

        | Check range
        /if (${Spawn[id ${PeerID}].Distance} > ${OOGRange}) {
            GZMDEBUG_OOG ${PeerName} out of range (${Spawn[id ${PeerID}].Distance} > ${OOGRange})
            /goto :nextPeer
        }

        | Get peer's class for class filtering
        /varset PeerClass ${Spawn[id ${PeerID}].Class.ShortName}

        GZMDEBUG_OOG Checking OOG buffs for ${PeerName} (${PeerClass})

        | Check and cast each OOG buff
        /if (${OOGBuff1.Length}) {
            /call ConditionOK Buffs OOGBuff1
            /if (${Macro.Return} && (${OOGBuff1Class.Equal[All]} || ${OOGBuff1Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${OOGBuff1}" "${PeerID}" "${PeerName}"
            }
        }
        /if (${OOGBuff2.Length}) {
            /call ConditionOK Buffs OOGBuff2
            /if (${Macro.Return} && (${OOGBuff2Class.Equal[All]} || ${OOGBuff2Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${OOGBuff2}" "${PeerID}" "${PeerName}"
            }
        }
        /if (${OOGBuff3.Length}) {
            /call ConditionOK Buffs OOGBuff3
            /if (${Macro.Return} && (${OOGBuff3Class.Equal[All]} || ${OOGBuff3Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${OOGBuff3}" "${PeerID}" "${PeerName}"
            }
        }
        /if (${OOGBuff4.Length}) {
            /call ConditionOK Buffs OOGBuff4
            /if (${Macro.Return} && (${OOGBuff4Class.Equal[All]} || ${OOGBuff4Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${OOGBuff4}" "${PeerID}" "${PeerName}"
            }
        }
        /if (${OOGBuff5.Length}) {
            /call ConditionOK Buffs OOGBuff5
            /if (${Macro.Return} && (${OOGBuff5Class.Equal[All]} || ${OOGBuff5Class.Find[${PeerClass}]})) {
                /call CheckAndCastBuffOOG "${OOGBuff5}" "${PeerID}" "${PeerName}"
            }
        }

        :nextPeer
    /next i
/return

| ============================================================================
| SUB: Check and Cast Buff on OOG Target (without target switching)
| Args: SpellName, TargetID, TargetName
| Uses -targetid to cast without switching current target
| ============================================================================
Sub CheckAndCastBuffOOG(string SpellName, int TargetID, string TargetName)
    | Skip empty spell names
    /if (!${SpellName.Length}) /return

    | Check if we have the spell
    /if (!${Me.Book[${SpellName}]}) {
        GZMDEBUG_OOG Don't have spell ${SpellName}
        /return
    }

    | Check if target already has the buff
    /if (${Spawn[id ${TargetID}].Buff[${SpellName}].ID}) {
        GZMDEBUG_OOG ${TargetName} already has ${SpellName}
        /return
    }

    | Check if we have mana (keep 20% reserve)
    /if (${Me.PctMana} < 20) /return

    | Check if we're already casting
    /if (${Me.Casting.ID}) /return

    | Check if spell is ready
    /if (!${Me.SpellReady[${SpellName}]}) {
        GZMDEBUG_OOG Spell ${SpellName} not ready
        /return
    }

    GZMDEBUG_OOG Casting OOG buff ${SpellName} on ${TargetName} (no target switch)

    | Cast using MQ2Cast with -targetid (no target switching!)
    /casting "${SpellName}" -targetid|${TargetID}
    /delay 5 ${Me.Casting.ID}
    /delay 15s !${Me.Casting.ID}

    /varset BuffsCast ${Math.Calc[${BuffsCast}+1]}
    /varset BuffTimer 30
/return

| ============================================================================
| SUB: Check and Cast Buff on Target (NO TARGET SWITCHING)
| Args: SpellName, TargetID
| Uses -targetid to cast without changing current target
| ============================================================================
Sub CheckAndCastBuff(string SpellName, int TargetID)
    | Skip empty spell names
    /if (!${SpellName.Length}) /return

    | Check if we have the spell
    /if (!${Me.Book[${SpellName}]}) {
        GZMDEBUG_BUFF Don't have spell ${SpellName}
        /return
    }

    | Check if target already has the buff (handle self vs others)
    /if (${TargetID} == ${Me.ID}) {
        | Self buff - check Me.Buff
        /if (${Me.Buff[${SpellName}].ID}) {
            GZMDEBUG_BUFF Already have ${SpellName} on self
            /return
        }
        | Also check song window for bard buffs
        /if (${Me.Song[${SpellName}].ID}) {
            GZMDEBUG_BUFF Already have song ${SpellName} on self
            /return
        }
    } else {
        | Other target - check target buff using spawn
        /if (${Spawn[id ${TargetID}].Buff[${SpellName}].ID}) {
            GZMDEBUG_BUFF ${Spawn[id ${TargetID}].CleanName} already has ${SpellName}
            /return
        }
    }

    | Check if we have mana (keep 20% reserve)
    /if (${Me.PctMana} < 20) /return

    | Check if we're already casting
    /if (${Me.Casting.ID}) /return

    | Check if buff timer is still running (prevent spam)
    /if (${BuffTimer}) {
        GZMDEBUG_BUFF Buff timer active (${BuffTimer}), waiting...
        /return
    }

    | Check if spell is ready
    /if (!${Me.SpellReady[${SpellName}]}) {
        GZMDEBUG_BUFF Spell ${SpellName} not ready
        /return
    }

    /declare TargetName string local ${Spawn[id ${TargetID}].CleanName}
    GZMDEBUG_BUFF Casting ${SpellName} on ${TargetName} (no target switch)

    | Cast using MQ2Cast with -targetid (NO TARGET SWITCHING!)
    /casting "${SpellName}" -targetid|${TargetID}
    /delay 5 ${Me.Casting.ID}
    /delay 15s !${Me.Casting.ID}

    /varset BuffsCast ${Math.Calc[${BuffsCast}+1]}

    | Wait briefly for buff to land and verify it worked
    /delay 10

    /declare buffLanded int local 0
    /if (${TargetID} == ${Me.ID}) {
        /if (${Me.Buff[${SpellName}].ID} || ${Me.Song[${SpellName}].ID}) {
            /varset buffLanded 1
        }
    } else {
        /if (${Spawn[id ${TargetID}].Buff[${SpellName}].ID}) {
            /varset buffLanded 1
        }
    }

    /if (${buffLanded}) {
        /echo \ag[Buff] ${SpellName} landed on ${TargetName}
        | Broadcast buff announcement if enabled
        /if (${BroadcastBuffs}) {
            /call BroadCast MQ "[Buff] ${Me.CleanName} cast ${SpellName} on ${TargetName}"
        }
    } else {
        GZMDEBUG_BUFF ${SpellName} may not have landed - will retry later
    }

    | Set buff timer to prevent rapid recasting
    /varset BuffTimer 50
/return

| ============================================================================
| SUB: Check Pulling
| ============================================================================
Sub CheckPulling
    /if (!${PullOn}) /return
    /if (${PullHold}) /return
    /if (${InCombat} && !${ChainPull}) /return

    | Chain pull check
    /if (${ChainPull} && ${InCombat}) {
        /if (${Target.PctHPs} > ${ChainPullHP}) /return
    }

    GZMDEBUG_PULL Checking for mobs to pull...

    /call FindMobToPull
    /if (${Macro.Return}) {
        /call PullMob ${Macro.Return}
    }
    /if (${Defined[CustomPullHook]}) /call CustomPullHook
/return

| ============================================================================
| SUB: Should Ignore Mob
| ============================================================================
Sub ShouldIgnoreMob(int MobID)
    /if (!${MobID}) /return 1
    /if (!${IgnoreList.Length}) /return 0
    /declare entries int local ${Math.Calc[${IgnoreList.Count[|]}+1]}
    /declare idx int local 1
    /declare token string local
    /for idx 1 to ${entries}
        /varset token ${IgnoreList.Arg[${idx},|]}
        /if (!${token.Length}) /next idx
        /if (${token.Lower.Equal[${Spawn[${MobID}].CleanName.Lower}]}) /return 1
    /next idx
/return 0

| ============================================================================
| SUB: Find Mob To Pull
| ============================================================================
Sub FindMobToPull
    /declare PullID int local 0
    /declare i int local

    | Prioritize explicit pull list
    /if (${PullList.Length}) {
        /declare listIdx int local 1
        /declare desired string local
        :PullListLoop
            /varset desired ${PullList.Arg[${listIdx},|]}
            /if (!${desired.Length}) /goto :PullSearch
            /varset PullID ${NearestSpawn[npc "${desired}" targetable radius ${PullRange} zradius ${PullZRange} noalert 5].ID}
            /if (${PullID}) {
                /call ShouldAvoidMob ${PullID}
                /if (${Macro.Return}) {
                    GZMDEBUG_PULL ${Spawn[${PullID}].CleanName} within restricted pull zone - skipping
                } else {
                    /call ShouldIgnoreMob ${PullID}
                    /if (!${Macro.Return}) /goto :FoundPull
                }
            }
            /varcalc listIdx ${listIdx}+1
            /goto :PullListLoop
    }

    :PullSearch
    | Use Nav if available for pathing
    /if (${UseNav} && ${PullNavOn} && ${Plugin[MQ2Nav].Name.Length}) {
        | Find nearest navigable mob
        /for i 1 to ${SpawnCount[npc targetable radius ${PullRange} zradius ${PullZRange} noalert 5]}
            /declare checkID int local ${NearestSpawn[${i},npc targetable radius ${PullRange} zradius ${PullZRange} noalert 5].ID}
            /if (${checkID} && ${Nav.PathExists[id ${checkID}]}) {
                /call ShouldAvoidMob ${checkID}
                /if (${Macro.Return}) {
                    /goto :NextNavCheck
                }
                /call ShouldIgnoreMob ${checkID}
                /if (!${Macro.Return}) {
                /varset PullID ${checkID}
                /break
            }
            }
            :NextNavCheck
        /next i
    } else {
        | Simple LOS check
        /for i 1 to ${SpawnCount[npc targetable radius ${PullRange} zradius ${PullZRange} los noalert 5]}
            /declare losID int local ${NearestSpawn[${i},npc targetable radius ${PullRange} zradius ${PullZRange} los noalert 5].ID}
            /if (${losID}) {
                /call ShouldAvoidMob ${losID}
                /if (${Macro.Return}) /goto :NextLosCheck
                /call ShouldIgnoreMob ${losID}
                /if (!${Macro.Return}) {
                    /varset PullID ${losID}
                    /break
                }
            }
            :NextLosCheck
        /next i
    }

    :FoundPull
    /if (${PullID}) {
    GZMDEBUG_PULL Found pull target: ${PullID} - ${Spawn[${PullID}].CleanName}
    } else {
        GZMDEBUG_PULL No pull target available
    }
/return ${PullID}

| ============================================================================
| SUB: Pull Mob
| ============================================================================
Sub PullMob(int MobID)
    /if (!${MobID}) /return

    GZMDEBUG_PULL Pulling ${Spawn[${MobID}].CleanName}

    /varset Pulling 1
    /target id ${MobID}
    /delay 5 ${Target.ID} == ${MobID}

    | Navigate to mob if needed
    /if (${UseNav} && ${Target.Distance} > 50 && ${Plugin[MQ2Nav].Name.Length}) {
        GZMDEBUG_NAV Navigating to pull target
        /nav id ${MobID}
        /delay 10s !${Nav.Active} || ${Target.Distance} < 50
        /squelch /nav stop
    }

    | Pull with spell/ability/arrow
    /call DoPullAction

    | Return to camp
    /if (${ReturnToCamp}) {
        /call ReturnToCampLoc
    }

    /varset Pulling 0
/return

| ============================================================================
| SUB: Do Pull Action
| Uses pull spell if configured, otherwise melee/ranged
| ============================================================================
Sub DoPullAction
    /if (!${Target.ID}) /return

    GZMDEBUG_PULL Executing pull action on ${Target.CleanName}

    | Try spell pull first if configured
    /if (${PullSpell.Length} && ${Spell[${PullSpell}].ID}) {
        /if (${Plugin[MQ2Cast].IsLoaded}) {
            /if (${Cast.Ready[${PullSpell}]}) {
                /casting "${PullSpell}" -maxtries|1
                /delay 1s ${Cast.Status.Equal[C]}
                /delay 10s !${Cast.Status.Equal[C]}
                /if (${Cast.Result.Equal[CAST_SUCCESS]}) {
                    /varset PullsDone ${Math.Calc[${PullsDone}+1]}
                    /return
                }
            }
        } else {
            /if (${Me.Gem[${PullSpell}]} && ${Me.SpellReady[${PullSpell}]}) {
                /cast "${PullSpell}"
                /delay 1s ${Me.Casting.ID}
                /delay 10s !${Me.Casting.ID}
                /varset PullsDone ${Math.Calc[${PullsDone}+1]}
                /return
            }
        }
    }

    | Try ranged attack if bow equipped and in range
    /if (${Me.Inventory[ranged].ID} && ${Target.Distance} > ${MeleeDistance} && ${Target.Distance} < 200) {
        /ranged
        /delay 10
        /varset PullsDone ${Math.Calc[${PullsDone}+1]}
        /return
    }

    | Melee pull as last resort
    /if (${Target.Distance} < ${MeleeDistance}) {
        /attack on
        /delay 5
        /attack off
        /varset PullsDone ${Math.Calc[${PullsDone}+1]}
    }
/return

| ============================================================================
| SUB: Check Movement
| ============================================================================
Sub CheckMovement
    | Chase handling
    /if (${ChaseAssist} && !${InCombat}) {
        /call DoChase
        /return
    }

    | Return to camp handling
    /if (${ReturnToCamp} && !${InCombat} && !${Pulling}) {
        /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]} > ${CampRadius}) {
            /call ReturnToCampLoc
        }
    }
/return

| ============================================================================
| SUB: Do Chase
| ============================================================================
Sub DoChase
    /declare ChaseID int local ${Spawn[=${WhoToChase}].ID}

    /if (!${ChaseID}) /return
    /if (${Spawn[${ChaseID}].Distance} < ${ChaseDistance}) /return

    GZMDEBUG_MOVE Chasing ${WhoToChase}

    /if (${UseNav} && ${Plugin[MQ2Nav].Name.Length}) {
        /if (!${Nav.Active}) {
            /nav id ${ChaseID}
        }
    } else {
        /if (!${AdvPath.Following}) {
            /squelch /afollow on ${ChaseID}
        }
    }

    /delay 5 ${Spawn[${ChaseID}].Distance} < ${ChaseDistance}

    /if (${Spawn[${ChaseID}].Distance} < ${ChaseDistance}) {
        /if (${Nav.Active}) /squelch /nav stop
        /if (${AdvPath.Following}) /squelch /afollow off
    }
/return

| ============================================================================
| SUB: Return To Camp Location
| ============================================================================
Sub ReturnToCampLoc
    GZMDEBUG_MOVE Returning to camp: ${CampXLoc}, ${CampYLoc}

    /if (${UseNav} && ${Plugin[MQ2Nav].Name.Length}) {
        /nav loc ${CampYLoc} ${CampXLoc} ${CampZLoc}
        /delay 10s !${Nav.Active}
    } else {
        /moveto loc ${CampYLoc} ${CampXLoc}
        /delay 10s !${MoveTo.Moving}
    }
/return

| ============================================================================
| SUB: Check Idle Tasks
| ============================================================================
Sub CheckIdleTasks
    /if (${InCombat}) /return
    /if (${Me.Moving}) /return

    | Meditate - but NOT if we recently fizzled (anti-bot detection)
    /if (${MedOn} && ${Me.PctMana} < ${MedStart} && ${Me.PctMana} < ${MedStop}) {
        | Don't sit immediately after a fizzle - looks like botting
        /if (${FizzleTimer}) {
            GZMDEBUG_CAST Not sitting - recently fizzled (${FizzleTimer} remaining)
        } else /if (!${Me.Sitting} && ${SitToMed}) {
            /sit
        }
    }

    | Forage (Enhanced - use new forage system if available)
    /if (${Defined[CheckForage]}) {
        /call CheckForage
    } else /if (${ForageOn} && ${Me.AbilityReady[Forage]}) {
        /doability Forage
    }

    | AA Purchasing
    /if (${Defined[AAPicker]}) {
        /if (${DoAA} && !${AACheckTimer}) {
            /call AAPicker
        }
    }

    | Cursor Clearing (stuck item handling)
    /if (${Defined[ClearCursor]}) {
        /if (${Cursor.ID}) {
            /call ClearCursor
        }
    }

    | Loot
    /if (${LootOn} && !${LootCombat}) {
        /call CheckLoot
    }
    /if (${Defined[CustomIdleHook]}) /call CustomIdleHook
/return

| ============================================================================
| SUB: Check Loot
| ============================================================================
Sub CheckLoot
    /if (${SpawnCount[corpse radius ${LootRadius}]} > 0) {
        /call LootMobs
    }
/return

| ============================================================================
| SUB: Check OOG (Out of Group Support)
| ============================================================================
Sub CheckOOG
    /if (!${UseDanNet}) /return

    GZMDEBUG_OOG Checking OOG support...

    | OOG Assist
    /if (${OOGAssistOn}) {
        /call CheckOOGAssist
    }
/return

| ============================================================================
| SUB: Check OOG Assist
| ============================================================================
Sub CheckOOGAssist
    /if (!${UseDanNet}) /return
    /if (!${OOGAssistOn}) /return
    /if (${Group.Member[${MainAssist}].ID}) /return
    /if (!${DanNet[${MainAssist}].ObserveSet}) /return

    /declare MainTarget int local ${DanNet[${MainAssist}].Observe[Target.ID].Int}
    /if (!${MainTarget}) /return
    /if (!${Spawn[${MainTarget}].ID}) /return

    | Only update if we are not already engaged
    /if (${MyTargetID} != ${MainTarget}) {
        /varset MyTargetID ${MainTarget}
        /echo \ag[GronnzMaster] OOG assist acquired target ${Spawn[${MainTarget}].CleanName}
    }
/return

| ============================================================================
| SUB: Handle Death
| ============================================================================
Sub HandleDeath
    | -------------------------------------------------------------------------
    | ENHANCED DEATH HANDLING
    | Full state reset, rez acceptance, consent, and recovery
    | -------------------------------------------------------------------------
    /echo \ar*** ${Me.CleanName} HAS DIED! ***
    /beep

    | Broadcast death via unified comm system
    /if (${Defined[BCastDeath]}) {
        /call BCastDeath
    } else /if (${UseDanNet}) {
        /dgt Death: ${Me.CleanName} has died in ${Zone.ShortName}!
    } else /if (${UseEQBC}) {
        /bc Death: ${Me.CleanName} has died in ${Zone.ShortName}!
    }

    | Set state to DEAD (if gzm_state.inc loaded)
    /if (${Defined[SetState]}) /call SetState DEAD

    | Disable ALL automation
    /varset InCombat 0
    /varset MyTargetID 0
    /varset HealsOn 0
    /varset BuffsOn 0
    /varset CuresOn 0
    /varset MezOn 0
    /varset DoCharm 0
    /varset DoPull 0
    /varset DoFollow 0
    /varset DoLoot 0

    | Reset combat state
    /if (${Defined[GMCombatTarget]}) /varset GMCombatTarget 0
    /if (${Defined[AssistTarget]}) /varset AssistTarget 0
    /squelch /target clear

    | Disable MQ2Melee and stop movement
    /squelch /melee plugin=0
    /squelch /nav stop
    /squelch /stick off
    /squelch /moveto off

    | Flush all pending events
    /doevents flush

    | Wait for rez handling
    /if (${AutoRezOn}) {
        /echo \ayWaiting for resurrection (min 90%, 300s timeout)...

        | Use gzm_death.inc's WaitForRez if available
        /if (${Defined[WaitForRez]}) {
            /call WaitForRez
        } else {
            | Fallback: Simple rez wait loop
            /declare RezTimer timer local 300s
            :WaitRezLoop
            /if (${Me.State.Equal[HOVER]}) {
                /if (${Window[ConfirmationDialogBox].Open}) {
                    /notify ConfirmationDialogBox Yes_Button leftmouseup
                    /delay 3s !${Me.State.Equal[HOVER]}
                }
                /delay 1s
                /if (${RezTimer}) /goto :WaitRezLoop
            }
        }
    }

    | Post-rez recovery
    /if (!${Me.State.Equal[HOVER]} && ${Me.CurrentHPs}>0) {
        /delay 3s
        /echo \agResurrection accepted - recovering...

        | Set state to IDLE
        /if (${Defined[SetState]}) /call SetState IDLE

        | Handle consent
        /if (${Group.Members}) {
            /consent group
            /delay 5
        }
        /if (${Raid.Members}) {
            /consent raid
            /delay 5
        }

        | Reload immunities if available
        /if (${Defined[LoadImmunes]}) /call LoadImmunes

        | Reset all timers
        /if (${Defined[ResetAllTimers]}) /call ResetAllTimers

        | Re-enable core automation
        /delay 3s
        /varset HealsOn 1
        /varset BuffsOn 1
        /varset CuresOn 1

        /echo \agHeals/Buffs/Cures enabled. Use /gm camp to resume full automation.
        /if (${Defined[BCast]}) {
            /call BCast Rez complete: ${Me.CleanName} recovered in ${Zone.ShortName}
        } else /if (${UseDanNet}) {
            /dgt Rez complete: ${Me.CleanName} recovered in ${Zone.ShortName}
        } else /if (${UseEQBC}) {
            /bc Rez complete: ${Me.CleanName} recovered in ${Zone.ShortName}
        }
    }
/return

| ============================================================================
| SUB: Handle Zoning
| ============================================================================
Sub HandleZoning
    | -------------------------------------------------------------------------
    | ENHANCED ZONE HANDLING
    | Full state reset, follow resumption, and event flushing
    | -------------------------------------------------------------------------
    /echo \ayZone transition detected...

    | Set state to ZONING
    /if (${Defined[SetState]}) /call SetState ZONING

    | Store follow target before reset
    /declare PreZoneFollowTarget string local
    /if (${Defined[GMFollowTarget]}) /varset PreZoneFollowTarget ${GMFollowTarget}

    | Stop all movement and combat
    /squelch /melee plugin=0
    /squelch /nav stop
    /squelch /stick off
    /squelch /moveto off

    | Wait for zone to complete
    /delay 3s

    /echo \agArrived in ${Zone.Name} (${Zone.ShortName})

    | -------------------------------------------------------------------------
    | FULL STATE RESET
    | -------------------------------------------------------------------------
    | Combat state
    /varset InCombat 0
    /varset MyTargetID 0
    /if (${Defined[GMCombatTarget]}) /varset GMCombatTarget 0
    /if (${Defined[AssistTarget]}) /varset AssistTarget 0

    | Clear targeting
    /squelch /target clear

    | Reset MQ2Melee
    /squelch /melee plugin=0

    | Clear stuck tracking
    /if (${Defined[StuckCount]}) /varset StuckCount 0

    | Mez tracking reset
    /if (${Defined[ClearMezList]}) /call ClearMezList

    | Debuff tracking reset
    /if (${Defined[ClearDebuffTracking]}) /call ClearDebuffTracking

    | Flush all pending events
    /doevents flush

    | Reset all timers
    /if (${Defined[ResetAllTimers]}) /call ResetAllTimers

    | Clear camp (camps don't persist across zones)
    /varset CampXLoc ${Me.X}
    /varset CampYLoc ${Me.Y}
    /varset CampZLoc ${Me.Z}
    /if (${Defined[GMCampActive]}) /varset GMCampActive FALSE
    /varset ReturnToCamp 0

    | Pet state reset
    /if (${Me.Pet.ID}) {
        /pet back off
        /pet follow
    }

    | -------------------------------------------------------------------------
    | RELOAD ZONE DATA
    | -------------------------------------------------------------------------
    | Load spell immunities for this zone
    /if (${Defined[LoadImmunes]}) /call LoadImmunes

    | -------------------------------------------------------------------------
    | RESUME FOLLOW (if we had a follow target)
    | -------------------------------------------------------------------------
    /if (${PreZoneFollowTarget.Length} && ${DoFollow}) {
        /echo \ayAttempting to resume follow on ${PreZoneFollowTarget}
        /delay 5s ${Spawn[pc ${PreZoneFollowTarget}].ID}
        /if (${Spawn[pc ${PreZoneFollowTarget}].ID}) {
            /echo \agResuming follow on ${PreZoneFollowTarget}
            /if (${Defined[GMFollowTarget]}) /varset GMFollowTarget ${PreZoneFollowTarget}
        } else {
            /echo \arFollow target ${PreZoneFollowTarget} not found in zone
            /varset DoFollow 0
            /if (${Defined[GMFollowTarget]}) /varset GMFollowTarget
        }
    }

    | -------------------------------------------------------------------------
    | RE-ENABLE CORE AUTOMATION
    | -------------------------------------------------------------------------
    | Set state to IDLE
    /if (${Defined[SetState]}) /call SetState IDLE

    | Re-enable heals, cures, buffs
    /varset HealsOn 1
    /varset CuresOn 1
    /varset BuffsOn 1

    | Broadcast zone complete via unified comm system
    /if (${Defined[BCastZone]}) {
        /call BCastZone
    } else /if (${UseDanNet}) {
        /dgt Zone: ${Me.CleanName} arrived in ${Zone.ShortName}
    } else /if (${UseEQBC}) {
        /bc Zone: ${Me.CleanName} arrived in ${Zone.ShortName}
    }

    /varset JustZoned 0
/return

| ============================================================================
| SUB: Broadcast Message
| ============================================================================
Sub BroadCast(string Channel, string Message)
    | Handle specific channel types
    /if (${Channel.Equal[MQ]}) {
        | Broadcast to MQ2 window (all characters see it)
        /if (${UseDanNet}) {
            /dgae /echo ${Message}
        } else /if (${UseEQBC}) {
            /bca ${Message}
        } else {
            /echo ${Message}
        }
    } else /if (${Channel.Equal[KNG]} || ${Channel.Equal[group]}) {
        | Broadcast to group
        /if (${UseDanNet}) {
            /dggae /echo ${Message}
        } else {
            /gsay ${Message}
        }
    } else /if (${UseDanNet}) {
        /dgae ${Message}
    } else /if (${UseEQBC}) {
        /bca ${Message}
    } else {
        /${BroadcastChannel} ${Message}
    }
/return

| ============================================================================
| EVENT HANDLERS
| ============================================================================

Sub Event_Camping
    /echo \ayCamping - ending macro
    /varset MacroRunning 0
/return

Sub Event_Zoned
    /varset JustZoned 1
/return

Sub Event_Joined(string Line, string Name)
    /echo \ag${Name} joined the group
/return

Sub Event_LeftGroup(string Line, string Name)
    /echo \ay${Name} left the group
/return

Sub Event_ImDead
    /call HandleDeath
/return

Sub Event_GotHit(string Line, string Attacker)
    GZMDEBUG_COMBAT Got hit by ${Attacker}
    | Could trigger auto-target or defensive abilities
/return

Sub Event_Enraged
    /varset Enraged 1
    GZMDEBUG_COMBAT Target ENRAGED!
/return

Sub Event_NotEnraged
    /varset Enraged 0
    GZMDEBUG_COMBAT Target no longer enraged
/return

Sub Event_MezBroke(string Line, string Mob, string Breaker)
    GZMDEBUG_MEZ Mez broke on ${Mob} by ${Breaker}
/return

Sub Event_GoMOn
    /varset GoMTimer 120s
    GZMDEBUG_CAST Gift of Mana ACTIVE
/return

Sub Event_GoMOff
    /varset GoMTimer 0
    GZMDEBUG_CAST Gift of Mana faded
/return

| ============================================================================
| Casting Event Handlers - Track fizzles/interrupts for anti-bot
| ============================================================================
Sub Event_CAST_FIZZLE
    /varset LastCastSuccess 0
    /varset FizzleTimer 50
    GZMDEBUG_CAST Spell fizzled! Not sitting for 5 seconds.
/return

Sub Event_CAST_INTERRUPTED
    /varset LastCastSuccess 0
    /varset FizzleTimer 30
    GZMDEBUG_CAST Spell interrupted! Not sitting for 3 seconds.
/return

Sub Event_CAST_BEGIN(string Line, string SpellName)
    | Cast started - reset success flag
    /varset LastCastSuccess 0
/return

Sub Event_WornOff(string Line, string Spell, string Target)
    GZMDEBUG_BUFF ${Spell} worn off ${Target}
/return

| ============================================================================
| SUB: Event - Buffs Please Handler
| ============================================================================
Sub Event_BuffsPlease(string Line, string PlayerName)
    | Only respond if buffs are enabled
    /if (!${BuffsOn}) /return

    | Clean player name (remove any trailing characters)
    /declare cleanName string local ${PlayerName.Arg[1, ]}

    GZMDEBUG_BUFF Buff request from ${cleanName}

    | Find the player
    /declare targetID int local ${Spawn[pc ${cleanName}].ID}
    /if (!${targetID}) {
        /echo [gzm_Buffs] Cannot find ${cleanName} for buff request
        /return
    }

    | Check if in combat - queue for later
    /if (${InCombat}) {
        /echo [gzm_Buffs] In combat - will buff ${cleanName} after combat
        /return
    }

    | Check distance
    /if (${Spawn[${targetID}].Distance}>200) {
        /tell ${cleanName} You're too far away for buffs!
        /return
    }

    /echo [gzm_Buffs] Buffing ${cleanName} on request

    | Call the buff routine with this target
    /if (${Defined[BuffTarget]}) {
        /call BuffTarget ${targetID}
    } else {
        | Fallback: target and cast main buffs
        /target id ${targetID}
        /delay 1s ${Target.ID}==${targetID}
        /if (${Target.ID}==${targetID}) {
            /call CheckBuffs
        }
    }

    /tell ${cleanName} Buffs incoming!
/return

Sub Event_Trigger1
    /echo \agTrigger 1 activated!
    | Custom trigger action
/return

Sub Event_Trigger2
    /echo \agTrigger 2 activated!
/return

Sub Event_Trigger3
    /echo \agTrigger 3 activated!
/return

Sub Event_Trigger4
    /echo \agTrigger 4 activated!
/return

Sub Event_Trigger5
    /echo \agTrigger 5 activated!
/return

| NOTE: Event_StartCHRot, Event_EndCHRot, and other CH events are now handled
| in gzm_chchain.inc. The #Event definitions above call those handlers directly.

Sub Event_TankTarget(string Line, string Tanker, string MobID, string MobName)
    GZMDEBUG_COMBAT Tank broadcast: ${Tanker} tanking ${MobName} (${MobID})
    /if (${MobID} && ${Spawn[${MobID}].ID}) {
        /varset MyTargetID ${MobID}
    }
/return

Sub Event_BagsFull
    /echo \arInventory is FULL!
    /varset LootOn 0
/return

| ============================================================================
| BIND HANDLERS
| ============================================================================

Sub Bind_GMHelp
    /echo \ag============================================
    /echo \ag  GronnzMaster v${GVERSION} Commands
    /echo \ag============================================
    /echo \aw /gmstatus - Show current status
    /echo \aw /gmreload - Reload INI settings
    /echo \aw /gmdebug [type] - Toggle debug
    /echo \aw /backoff - Stop combat
    /echo \aw /burn - Activate burns
    /echo \aw /makecamphere - Set camp location
    /echo \aw /chaseme - Make others chase you
    /echo \aw /switchma [name] - Change main assist
    /echo \aw /pullhold - Toggle pull hold
    /echo \aw /navto [loc/id] - Navigate somewhere
    /echo \aw /gm ini <section> <key> [value] - View/set INI entries
    /echo \aw /gm cond <section> <entry> [expr] - Manage conditions
    /echo \aw /gm pullzone ... - Manage pull restriction zones
    /echo \aw /gm lists <pull|ignore> - Show pull/ignore lists
    /echo \aw /gm conditions <on|off|reload> - Manage conditions
    /echo \ag-------- CH Chain Commands --------
    /echo \aw /startch c1 c2 c3... - Start CH rotation
    /echo \aw /stopch - Stop CH rotation
    /echo \aw /chtarget [name] - Set CH target
    /echo \aw /chdelay [tenths] - Set/show delay
    /echo \aw /chduck [on|off] - Toggle duck heals
    /echo \aw /chstatus - Show CH chain status
    /echo \ag============================================
/return

Sub Bind_GMSettings
    /echo \ag========== GronnzMaster Settings ==========
    /echo \aw Role: ${Role} | MainAssist: ${MainAssist} | AssistAt: ${AssistAt}%
    /echo \aw CampRadius: ${CampRadius} | ReturnToCamp: ${ReturnToCamp}
    /echo \aw MeleeOn: ${MeleeOn} | DPSOn: ${DPSOn} | HealsOn: ${HealsOn}
    /echo \aw BuffsOn: ${BuffsOn} | OOG: ${OOGOn} | PullOn: ${PullOn}
    /echo \aw ConditionsOn: ${ConditionsOn} | AutoGUI: ${AutoLaunchGUI} | AutoHUD: ${AutoLaunchHUD}
    /echo \ag==========================================
/return

Sub Bind_GMStatus
    /echo \ag============================================
    /echo \ag  GronnzMaster Status
    /echo \ag============================================
    /echo \aw Role: ${Role} | MA: ${MainAssist} | AssistAt: ${AssistAt}%
    /echo \aw InCombat: ${InCombat} | Target: ${MyTargetID}
    /echo \aw Camp: ${CampXLoc}, ${CampYLoc} | Radius: ${CampRadius}
    /echo \aw Chase: ${ChaseAssist} | ReturnToCamp: ${ReturnToCamp}
    /echo \aw Heals: ${HealsOn} | Buffs: ${BuffsOn} | DPS: ${DPSOn}
    /echo \aw Pull: ${PullOn} | PullHold: ${PullHold}
    /echo \aw DanNet: ${UseDanNet} | EQBC: ${UseEQBC} | Nav: ${UseNav}
    /echo \aw OOG: ${OOGOn}
    /echo \ag============================================
/return

Sub Bind_GMReload
    /echo \ayReloading settings...
    /call LoadAllSettings
    /echo \agSettings reloaded!
/return

Sub Bind_GMDebug(string DebugType)
    /if (!${DebugType.Length} || ${DebugType.Equal[all]}) {
        /varset DebugAll ${If[${DebugAll},0,1]}
        /varset Debug ${DebugAll}
        /varset DebugBuffs ${DebugAll}
        /varset DebugCast ${DebugAll}
        /varset DebugCombat ${DebugAll}
        /varset DebugHeal ${DebugAll}
        /varset DebugMove ${DebugAll}
        /varset DebugMez ${DebugAll}
        /varset DebugPet ${DebugAll}
        /varset DebugPull ${DebugAll}
        /varset DebugNav ${DebugAll}
        /varset DebugOOG ${DebugAll}
        /varset DebugDanNet ${DebugAll}
        /echo \ayAll debug: ${If[${DebugAll},ON,OFF]}
    } else /if (${DebugType.Equal[buff]}) {
        /varset DebugBuffs ${If[${DebugBuffs},0,1]}
        /echo \ayBuff debug: ${If[${DebugBuffs},ON,OFF]}
    } else /if (${DebugType.Equal[combat]}) {
        /varset DebugCombat ${If[${DebugCombat},0,1]}
        /echo \ayCombat debug: ${If[${DebugCombat},ON,OFF]}
    } else /if (${DebugType.Equal[heal]}) {
        /varset DebugHeal ${If[${DebugHeal},0,1]}
        /echo \ayHeal debug: ${If[${DebugHeal},ON,OFF]}
    } else /if (${DebugType.Equal[pull]}) {
        /varset DebugPull ${If[${DebugPull},0,1]}
        /echo \ayPull debug: ${If[${DebugPull},ON,OFF]}
    } else /if (${DebugType.Equal[nav]}) {
        /varset DebugNav ${If[${DebugNav},0,1]}
        /echo \ayNav debug: ${If[${DebugNav},ON,OFF]}
    } else /if (${DebugType.Equal[oog]}) {
        /varset DebugOOG ${If[${DebugOOG},0,1]}
        /echo \ayOOG debug: ${If[${DebugOOG},ON,OFF]}
    } else /if (${DebugType.Equal[items]}) {
        /varset DebugItems ${If[${DebugItems},0,1]}
        /echo \ayItems debug: ${If[${DebugItems},ON,OFF]}
    } else /if (${DebugType.Equal[mez]}) {
        /varset DebugMez ${If[${DebugMez},0,1]}
        /echo \ayMez debug: ${If[${DebugMez},ON,OFF]}
    } else /if (${DebugType.Equal[pet]}) {
        /varset DebugPet ${If[${DebugPet},0,1]}
        /echo \ayPet debug: ${If[${DebugPet},ON,OFF]}
    }
/return

Sub Bind_BackOff
    /echo \ayBacking off for 3 hours...
    /varset BackOffFlag 108000
    /if (${Me.Combat}) /attack off
    /if (${Stick.Active}) /squelch /stick off
    /varset InCombat 0
/return

Sub Bind_Burn
    /varset BurnNow ${If[${BurnNow},0,1]}
    /echo \ayBurn: ${If[${BurnNow},ACTIVATED,DEACTIVATED]}
    /if (${BurnNow} && ${UseDanNet}) {
        /dgae /echo Burn activated by ${Me.CleanName}!
    }
/return

Sub Bind_MakeCampHere
    /varset CampXLoc ${Me.X}
    /varset CampYLoc ${Me.Y}
    /varset CampZLoc ${Me.Z}
    /varset ReturnToCamp 1
    /echo \agCamp set at ${CampXLoc}, ${CampYLoc}
/return

Sub Bind_ChaseMe
    /if (${UseDanNet}) {
        /dgae /varset WhoToChase ${Me.CleanName}
        /dgae /varset ChaseAssist 1
        /echo \agAll characters now chasing ${Me.CleanName}
    }
/return

Sub Bind_StayHere
    /varset ChaseAssist 0
    /varset ReturnToCamp 0
    /if (${Nav.Active}) /squelch /nav stop
    /if (${Stick.Active}) /squelch /stick off
    /echo \ayStaying here - chase and camp disabled
/return

Sub Bind_SwitchMA(string NewMA)
    /if (${NewMA.Length}) {
        /varset MainAssist ${NewMA}
    } else /if (${Target.ID}) {
        /varset MainAssist ${Target.CleanName}
    }

    | Update IAmMA flag
    /if (${MainAssist.Equal[${Me.CleanName}]}) {
        /varset IAmMA 1
        /echo \ag[GronnzMaster] I am now the Main Assist - will pick my own targets
    } else {
        /varset IAmMA 0
        /echo \ag[GronnzMaster] Main Assist changed to: ${MainAssist}
    }
/return

Sub Bind_SwitchNow
    /varset BackOffFlag 0
    /call AcquireTarget
    /echo \aySwitching to MA's target now
/return

Sub Bind_PullHold
    /varset PullHold ${If[${PullHold},0,1]}
    /echo \ayPull Hold: ${If[${PullHold},ON,OFF]}
/return

Sub Bind_ToggleVariable(string VarName)
    /if (${Defined[${VarName}]}) {
        /varset ${VarName} ${If[${${VarName}},0,1]}
        /echo \ay${VarName}: ${If[${${VarName}},ON,OFF]}
    } else {
        /echo \arVariable ${VarName} not found
    }
/return

Sub Bind_ChangeVarInt(string Section, string VarName, int NewValue)
    /if (${Defined[${VarName}]}) {
        /varset ${VarName} ${NewValue}
        /ini "${IniFileName}" "${Section}" "${VarName}" "${NewValue}"
        /echo \ay${VarName} set to ${NewValue}
    } else {
        /echo \arVariable ${VarName} not found
    }
/return

Sub Bind_NavTo(string Destination)
    /if (!${Plugin[MQ2Nav].Name.Length}) {
        /echo \arMQ2Nav not loaded!
        /return
    }

    /if (${Destination.Left[2].Equal[id]}) {
        /nav ${Destination}
    } else /if (${Destination.Left[3].Equal[loc]}) {
        /nav ${Destination}
    } else {
        /echo \ayUsage: /navto id <spawnid> OR /navto loc <y> <x> <z>
    }
/return

Sub Bind_ZoneInfo
Sub Bind_SetPullRanking(string Entry)
    /if (!${Entry.Length}) {
        /echo \arUsage: /setpullranking <mob name|clear>
        /return
    }
    /if (${Entry.Equal[clear]}) {
        /call SaveList Pull ""
        /echo \ayPull list cleared.
        /return
    }
    /call AddNameToList Pull "${Entry}"
/return

Sub Bind_BuffGroup
    /echo \ag[GronnzMaster] Forcing group buff cycle...
    /call CheckGroupBuffs
/return

Sub Bind_GZMCast(string Args)
    /declare SpellName string local ${Args.Arg[1]}
    /declare TargetToken string local ${Args.Arg[2]}
    /declare TargetID int local 0

    /if (!${SpellName.Length}) {
        /echo \arUsage: /gzmcast <spell/item> [target]
        /return
    }

    /if (${TargetToken.Length}) {
        /if (${TargetToken.Equal[self]}) {
            /varset TargetID ${Me.ID}
        } else /if (${Int[${TargetToken}]}) {
            /varset TargetID ${TargetToken}
        } else {
            /varset TargetID ${Spawn[${TargetToken}].ID}
        }
    } else /if (${Target.ID}) {
        /varset TargetID ${Target.ID}
    } else {
        /varset TargetID ${Me.ID}
    }

    /if (!${TargetID}) {
        /echo \arUnable to resolve target for ${SpellName}
        /return
    }

    /echo \ag[GronnzMaster] Casting ${SpellName} on ${Spawn[${TargetID}].CleanName}
    /casting "${SpellName}" -targetid|${TargetID}
/return

Sub Bind_AddPull(string MobName)
    /declare Entry string local ${MobName}
    /if (${Entry.Equal[clear]}) {
        /call SaveList Pull ""
        /echo \ayPull list cleared.
        /return
    }
    /if (!${Entry.Length} && ${Target.ID}) {
        /varset Entry ${Target.CleanName}
    }
    /if (!${Entry.Length}) {
        /echo \arUsage: /addpull [mob name] (or target an NPC)
        /return
    }
    /call AddNameToList Pull "${Entry}"
/return

Sub Bind_AddIgnore(string MobName)
    /declare Entry string local ${MobName}
    /if (${Entry.Equal[clear]}) {
        /call SaveList Ignore ""
        /echo \ayIgnore list cleared.
        /return
    }
    /if (!${Entry.Length} && ${Target.ID}) {
        /varset Entry ${Target.CleanName}
    }
    /if (!${Entry.Length}) {
        /echo \arUsage: /addignore [mob name] (or target an NPC)
        /return
    }
    /call AddNameToList Ignore "${Entry}"
/return

Sub Bind_OOGAssist
    /varset OOGAssistOn ${If[${OOGAssistOn},0,1]}
    /echo \ayOOG Assist: ${If[${OOGAssistOn},ON,OFF]}
/return

Sub Bind_OOGBuff
    /varset OOGBuffOn ${If[${OOGBuffOn},0,1]}
    /echo \ayOOG Buffs: ${If[${OOGBuffOn},ON,OFF]}
/return

Sub Bind_OOGHeal
    /varset OOGHealOn ${If[${OOGHealOn},0,1]}
    /echo \ayOOG Heals: ${If[${OOGHealOn},ON,OFF]}
/return
    /echo \ag============================================
    /echo \ag  Zone Information
    /echo \ag============================================
    /echo \aw Zone: ${Zone.Name} (${Zone.ShortName})
    /echo \aw Location: ${Me.X}, ${Me.Y}, ${Me.Z}
    /echo \aw Heading: ${Me.Heading}
    /echo \aw NPCs in zone: ${SpawnCount[npc]}
    /echo \aw PCs in zone: ${SpawnCount[pc]}
    /echo \ag============================================
/return

| ============================================================================
| BIND HANDLER: Unified /gm Command Parser
| ============================================================================
Sub Bind_GMCommand(string Args)
    /declare CmdName string local
    /declare Arg1 string local
    /declare Arg2 string local
    /declare Arg3 string local

    | Parse arguments
    /varset CmdName ${Args.Arg[1]}
    /varset Arg1 ${Args.Arg[2]}
    /varset Arg2 ${Args.Arg[3]}
    /varset Arg3 ${Args.Arg[4]}

    | Convert to lowercase for comparison
    /varset CmdName ${CmdName.Lower}

    | No command given - show help
    /if (!${CmdName.Length}) {
        /call Bind_GMHelp
        /return
    }

    | -------------------------------------------------------------------------
    | Command: burn
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[burn]}) {
        /call Bind_Burn
        /return
    }

    | -------------------------------------------------------------------------
    | Command: pause
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[pause]}) {
        /varset Paused 1
        /echo \ayMacro PAUSED
        /if (${Me.Combat}) /attack off
        /if (${Stick.Active}) /squelch /stick off
        /if (${Nav.Active}) /squelch /nav stop
        /return
    }

    | -------------------------------------------------------------------------
    | Command: resume / unpause
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[resume]} || ${CmdName.Equal[unpause]}) {
        /varset Paused 0
        /echo \agMacro RESUMED
        /return
    }

    | -------------------------------------------------------------------------
    | Command: makecamp / camp
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[makecamp]} || ${CmdName.Equal[camp]}) {
        /call Bind_MakeCampHere
        /return
    }

    | -------------------------------------------------------------------------
    | Command: clearcamp
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[clearcamp]}) {
        /varset ReturnToCamp 0
        /varset CampXLoc 0
        /varset CampYLoc 0
        /varset CampZLoc 0
        /echo \ayCamp cleared
        /return
    }

    | -------------------------------------------------------------------------
    | Command: reload
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[reload]}) {
        /call Bind_GMReload
        /return
    }

    | -------------------------------------------------------------------------
    | Command: save
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[save]}) {
        /call SaveAllSettings
        /return
    }

    | -------------------------------------------------------------------------
    | Command: status
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[status]}) {
        /call Bind_GMStatus
        /return
    }

    | -------------------------------------------------------------------------
    | Command: settings
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[settings]}) {
        /call Bind_GMSettings
        /return
    }

    | -------------------------------------------------------------------------
    | Command: ini <section> <key> [value...]
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[ini]}) {
        /declare IniValue string local ${Arg3}
        /declare IniIdx int local 4
        /for IniIdx 4 to 50
            /if (!${Args.Arg[${IniIdx}].Length}) /goto :GMIniArgsDone
            /if (${IniValue.Length}) {
                /varset IniValue ${IniValue} ${Args.Arg[${IniIdx}]}
            } else {
                /varset IniValue ${Args.Arg[${IniIdx}]}
            }
        /next IniIdx
        :GMIniArgsDone
        /call GMIniCommand ${Arg1} ${Arg2} "${IniValue}"
        /return
    }

    | -------------------------------------------------------------------------
    | Command: cond <section> <entry> [expression...]
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[cond]}) {
        /declare CondExpr string local ${Arg3}
        /declare CondIdx int local 4
        /for CondIdx 4 to 50
            /if (!${Args.Arg[${CondIdx}].Length}) /goto :GMCondArgsDone
            /if (${CondExpr.Length}) {
                /varset CondExpr ${CondExpr} ${Args.Arg[${CondIdx}]}
            } else {
                /varset CondExpr ${Args.Arg[${CondIdx}]}
            }
        /next CondIdx
        :GMCondArgsDone
        /call GMConditionCommand ${Arg1} ${Arg2} "${CondExpr}"
        /return
    }

    | -------------------------------------------------------------------------
    | Command: help
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[help]}) {
        /call Bind_GMHelp
        /return
    }

    | -------------------------------------------------------------------------
    | Command: assist <name>
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[assist]}) {
        /if (${Arg1.Length}) {
            /call Bind_SwitchMA ${Arg1}
        } else {
            /echo \arUsage: /gm assist <name>
        }
        /return
    }

    | -------------------------------------------------------------------------
    | Command: debug <type>
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[debug]}) {
        /call Bind_GMDebug ${Arg1}
        /return
    }

    | -------------------------------------------------------------------------
    | Command: chase <name>
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[chase]}) {
        /if (${Arg1.Length}) {
            /varset WhoToChase ${Arg1}
        } else {
            /varset WhoToChase ${MainAssist}
        }
        /varset ChaseAssist 1
        /echo \agChase enabled - following ${WhoToChase}
        /return
    }

    | -------------------------------------------------------------------------
    | Command: stopchase
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[stopchase]}) {
        /varset ChaseAssist 0
        /echo \ayChase disabled
        /return
    }

    | -------------------------------------------------------------------------
    | Command: backoff
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[backoff]}) {
        /call Bind_BackOff
        /return
    }

    | -------------------------------------------------------------------------
    | Command: pullhold
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[pullhold]}) {
        /call Bind_PullHold
        /return
    }

    | -------------------------------------------------------------------------
    | Command: gui - Launch the GUI
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[gui]}) {
        /lua run GronnzMaster_gui
        /return
    }

    | -------------------------------------------------------------------------
    | Command: hud - Launch the HUD
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[hud]}) {
        /lua run GronnzMaster_hud
        /return
    }

    | -------------------------------------------------------------------------
    | Command: lists <pull|ignore>
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[lists]}) {
        /if (${Arg1.Equal[pull]}) {
            /call ShowList Pull
        } else /if (${Arg1.Equal[ignore]}) {
            /call ShowList Ignore
        } else {
            /echo \arUsage: /gm lists <pull|ignore>
        }
        /return
    }

    | -------------------------------------------------------------------------
    | Command: conditions <on|off|reload>
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[conditions]}) {
        /if (${Arg1.Equal[on]}) {
            /varset ConditionsOn 1
            /ini "${IniFileName}" "General" "ConditionsOn" "1"
            /echo \agConditions enabled.
        } else /if (${Arg1.Equal[off]}) {
            /varset ConditionsOn 0
            /ini "${IniFileName}" "General" "ConditionsOn" "0"
            /echo \ayConditions disabled.
        } else /if (${Arg1.Equal[reload]}) {
            /call EnsureConditionsFile
            /echo \agConditions file ensured at ${ConditionsFileName}
        } else {
            /echo \arUsage: /gm conditions <on|off|reload>
        }
        /return
    }

    | -------------------------------------------------------------------------
    | Command: pullzone <add|clear|list|on|off>
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[pullzone]}) {
        /if (${Arg1.Equal[add]}) {
            /declare Radius float local ${If[${Arg2.Length},${Arg2},50]}
            /call AddPullLoc ${Me.Y} ${Me.X} ${Radius}
        } else /if (${Arg1.Equal[list]}) {
            /call ShowPullLocs
        } else /if (${Arg1.Equal[clear]}) {
            /if (!${Arg2.Length} || ${Arg2.Equal[all]}) {
                /call ClearPullLoc 0
            } else {
                /call ClearPullLoc ${Arg2}
            }
        } else /if (${Arg1.Equal[on]}) {
            /varset PullLocsOn 1
            /call SavePullLocs
            /echo \ag[PullLoc] Restrictions enabled.
        } else /if (${Arg1.Equal[off]}) {
            /varset PullLocsOn 0
            /call SavePullLocs
            /echo \ay[PullLoc] Restrictions disabled.
        } else {
            /echo \arUsage: /gm pullzone add [radius] | clear [index|all] | list | on | off
        }
        /return
    }

    | -------------------------------------------------------------------------
    | Command: toggle <varname>
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[toggle]}) {
        /if (${Arg1.Length}) {
            /call Bind_ToggleVariable ${Arg1}
        } else {
            /echo \arUsage: /gm toggle <variable>
        }
        /return
    }

    | -------------------------------------------------------------------------
    | Command: set <varname> <value>
    | -------------------------------------------------------------------------
    /if (${CmdName.Equal[set]}) {
        /if (${Arg1.Length} && ${Arg2.Length}) {
            /if (${Defined[${Arg1}]}) {
                /varset ${Arg1} ${Arg2}
                /echo \ay${Arg1} set to ${Arg2}
            } else {
                /echo \arVariable ${Arg1} not found
            }
        } else {
            /echo \arUsage: /gm set <variable> <value>
        }
        /return
    }

    | -------------------------------------------------------------------------
    | Unknown command
    | -------------------------------------------------------------------------
    /echo \arUnknown command: /gm ${CmdName}
    /echo \awUse \ay/gm help\aw for available commands
/return

| ============================================================================
| SUB: Check Cures - Cure poison, disease, curse, corruption
| ============================================================================
Sub CheckCures
    /if (!${CuresOn}) /return
    /if (${CureTimer}) /return
    /if (${Me.Casting.ID}) /return

    /declare i int local
    /declare MemberID int local
    /declare NeedsCure int local 0
    /declare CureType string local
    /declare CureTarget int local 0

    | Check self first
    /if (${CurePoison} && ${Me.Poisoned.ID}) {
        /varset NeedsCure 1
        /varset CureType Poison
        /varset CureTarget ${Me.ID}
    } else /if (${CureDisease} && ${Me.Diseased.ID}) {
        /varset NeedsCure 1
        /varset CureType Disease
        /varset CureTarget ${Me.ID}
    } else /if (${CureCurse} && ${Me.Cursed.ID}) {
        /varset NeedsCure 1
        /varset CureType Curse
        /varset CureTarget ${Me.ID}
    } else /if (${CureCorrupt} && ${Me.Corrupted.ID}) {
        /varset NeedsCure 1
        /varset CureType Corrupt
        /varset CureTarget ${Me.ID}
    }

    | Check group members via Target (must briefly target to check debuffs)
    | Note: Spawn TLO doesn't have Poisoned/Diseased/Cursed - only Me and Target do
    /if (!${NeedsCure} && ${Target.ID} && ${Target.Type.Equal[PC]}) {
        | Check current target if it's a group member
        /if (${Group.Member[${Target.Name}].ID}) {
            /if (${CurePoison} && ${Target.Poisoned.ID}) {
                /varset NeedsCure 1
                /varset CureType Poison
                /varset CureTarget ${Target.ID}
            } else /if (${CureDisease} && ${Target.Diseased.ID}) {
                /varset NeedsCure 1
                /varset CureType Disease
                /varset CureTarget ${Target.ID}
            } else /if (${CureCurse} && ${Target.Cursed.ID}) {
                /varset NeedsCure 1
                /varset CureType Curse
                /varset CureTarget ${Target.ID}
            }
        }
    }

    | Cast cure if needed - uses -targetid to avoid target switching
    /if (${NeedsCure} && ${CureTarget}) {
        /declare CureSpell string local

        | Find appropriate cure spell
        /if (${CureSpell1Type.Find[${CureType}]} && ${CureSpell1.Length}) {
            /varset CureSpell ${CureSpell1}
        } else /if (${CureSpell2Type.Find[${CureType}]} && ${CureSpell2.Length}) {
            /varset CureSpell ${CureSpell2}
        } else /if (${CureSpell3Type.Find[${CureType}]} && ${CureSpell3.Length}) {
            /varset CureSpell ${CureSpell3}
        }

        /if (${CureSpell.Length} && ${Me.Book[${CureSpell}]} && ${Me.SpellReady[${CureSpell}]}) {
            | Cast using -targetid (no target switching!)
            GZMDEBUG_HEAL Curing ${CureType} on ${Spawn[${CureTarget}].CleanName} (no target switch)
            /casting "${CureSpell}" -targetid|${CureTarget}
            /delay 5 ${Me.Casting.ID}
            /delay 15s !${Me.Casting.ID}
            /varset CuresCast ${Math.Calc[${CuresCast}+1]}
            /echo \ag[Cure] Cured ${CureType} on ${Spawn[${CureTarget}].CleanName}
        }

        /varset CureTimer 20
    }
/return

| ============================================================================
| SUB: Do Bard Stuff - Handle bard twisting and melodies
| ============================================================================
Sub DoBardStuff
    /if (!${IAmABard}) /return
    /if (!${Plugin[MQ2Twist].Name.Length}) /return

    | Check if we should be twisting
    /if (${InCombat}) {
        | Combat melody
        /if (${CombatMelody.Length} && !${Twist.Twisting}) {
            /twist ${CombatMelody}
            /varset DPSTwisting 1
        }
        | Melee twist if enabled and in melee range
        /if (${MeleeTwistOn} && ${Target.Distance} <= ${MeleeDistance}) {
            /if (${MeleeTwist.Length} && !${Twist.Twisting}) {
                /twist ${MeleeTwist}
            }
        }
    } else {
        | Out of combat - rest melody or stop
        /if (${RestMelody.Length}) {
            /if (!${Twist.Twisting} || ${DPSTwisting}) {
                /twist ${RestMelody}
                /varset DPSTwisting 0
            }
        } else /if (${Twist.Twisting} && ${Me.PctMana} < ${MedStart}) {
            /twist stop
            /varset DPSTwisting 0
        }
    }
/return

| ============================================================================
| SUB: Feign Death Check - Handle FD for aggro control
| ============================================================================
Sub FeignAggroCheck
    /if (!${FDOn}) /return
    /if (!${Me.Feigning} && !${IAmFeigned}) /return

    | If we're feigned, check if safe to stand
    /if (${Me.Feigning}) {
        /varset IAmFeigned 1
        /delay ${FDAggroDelay}

        | Check if mobs are still on us
        /if (${SpawnCount[npc targetable radius 50 zradius 20]} == 0) {
            /stand
            /varset IAmFeigned 0
            /echo \ag[FD] Safe to stand - no mobs nearby
        } else /if (!${Me.TargetOfTarget.ID} || ${Me.TargetOfTarget.ID} != ${Me.ID}) {
            /stand
            /varset IAmFeigned 0
            /echo \ag[FD] Safe to stand - not targeted
        }
    }
/return

| ============================================================================
| SUB: Do Feign Death - Emergency FD when low health
| ============================================================================
Sub DoFeignDeath
    /if (!${FDOn}) /return
    /if (${Me.Feigning}) /return
    /if (!${FDSpell.Length}) /return

    | Check if we should FD
    /if (${Me.PctHPs} <= ${FDHPPct} && ${InCombat}) {
        /echo \ay[FD] Emergency Feign Death at ${Me.PctHPs}% HP!

        /if (${Me.Book[${FDSpell}]}) {
            /call CastSpellOnTarget "${FDSpell}"
        } else /if (${Me.AltAbility[${FDSpell}]}) {
            /aa act ${FDSpell}
        } else /if (${Me.CombatAbility[${FDSpell}]}) {
            /disc ${FDSpell}
        }

        /varset IAmFeigned 1
    }
/return

| ============================================================================
| SUB: Mercs Do What - Control mercenary behavior
| ============================================================================
Sub MercsDoWhat
    /if (!${MercOn}) /return
    /if (!${Me.Mercenary.ID}) /return

    | Check merc stance
    /if (${Me.Mercenary.Stance.NotEqual[${MercStance}]}) {
        /merc stance ${MercStance}
    }

    | Merc assist in combat
    /if (${MercAssist} && ${InCombat} && ${MyTargetID}) {
        /if (${Me.Mercenary.State.Equal[PASSIVE]}) {
            /merc attack
        }
    }

    | Suspend merc if enabled and out of combat
    /if (${MercSuspendOn} && !${InCombat}) {
        /if (${Me.Mercenary.State.NotEqual[SUSPENDED]}) {
            /merc suspend
        }
    }
/return

| ============================================================================
| SUB: Check MA Status - Handle MA death failover
| ============================================================================
Sub CheckMAStatus
    /if (!${OffTankOn}) /return
    /if (${IAmMA}) /return

    | Check if MA is alive
    /if (!${Spawn[=${MainAssist}].ID} || ${Spawn[=${MainAssist}].Dead}) {
        /if (!${MADownTimer}) {
            /varset MADownTimer ${MAFailoverDelay}
            /echo \ar[OffTank] Main Assist ${MainAssist} is down! Failover in ${MAFailoverDelay}s
        }

        | Failover if timer expired
        /if (${MADownTimer} <= 1) {
            /varset OrigMainAssist ${MainAssist}
            /varset MainAssist ${Me.CleanName}
            /varset IAmMA 1
            /echo \ag[OffTank] Taking over as Main Assist!
        }
    } else {
        | MA is back - restore if we took over
        /if (${OrigMainAssist.Length} && ${OrigMainAssist.NotEqual[${MainAssist}]}) {
            /if (${Spawn[=${OrigMainAssist}].ID} && !${Spawn[=${OrigMainAssist}].Dead}) {
                /varset MainAssist ${OrigMainAssist}
                /varset IAmMA 0
                /varset MADownTimer 0
                /echo \ag[OffTank] Original MA ${OrigMainAssist} is back!
            }
        } else {
            /varset MADownTimer 0
        }
    }
/return

| ============================================================================
| SUB: AE Check - Check for AE danger and flee if needed
| ============================================================================
Sub AECheck
    /if (!${AECheckOn}) /return
    /if (${DodgeAE}) {
        | DodgeAE is set by MQ2Events - run to waypoint
        /if (${AERunToWP.Length} && ${UseNav}) {
            /nav wp ${AERunToWP}
            /delay 30 !${Navigation.Active}
        }
        /return
    }

    | Count nearby mobs
    /varset MobCount ${SpawnCount[npc targetable radius ${AEFleeRange} zradius ${MaxZRange}]}

    | If too many mobs, consider fleeing
    /if (${MobCount} >= ${AEMobCount} && ${Me.PctHPs} < ${AEFleeHP}) {
        /echo \ar[AE] Warning: ${MobCount} mobs nearby and HP at ${Me.PctHPs}%!

        /if (${AERunToWP.Length} && ${UseNav}) {
            /echo \ay[AE] Fleeing to waypoint: ${AERunToWP}
            /nav wp ${AERunToWP}
        }
    }
/return

| ============================================================================
| SUB: Recover Corpses - Drag corpse back to camp
| ============================================================================
Sub RecoverCorpses
    /if (!${CorpseRecoveryOn}) /return

    /declare CorpseCount int local ${SpawnCount[pccorpse ${Me} radius 200]}

    /if (${CorpseCount} && !${DragCorpse}) {
        /echo \ay[Corpse] Found ${CorpseCount} corpse(s) to recover
        /varset DragCorpse 1

        | Target nearest corpse
        /target pccorpse ${Me}
        /delay 10 ${Target.Type.Equal[Corpse]}

        | Drag it
        /if (${Target.Type.Equal[Corpse]}) {
            /corpse
        }
    }

    | Check if corpse is at camp
    /if (${DragCorpse}) {
        /if (${SpawnCount[pccorpse ${Me} radius 30]} > 0) {
            /varset DragCorpse 0
            /echo \ag[Corpse] Corpse recovered to camp
        }
    }
/return

| ============================================================================
| SUB: Campfire Back - Click campfire to return to camp
| ============================================================================
Sub CampfireBack
    /if (!${ClickBacktoCamp}) /return
    /if (!${Spawn[Fellowship Campfire].ID}) /return
    /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]} < ${CampRadius}) /return

    | Click campfire if far from camp
    /if (${Spawn[Fellowship Campfire].Distance} < 20) {
        /target Fellowship Campfire
        /delay 5 ${Target.Type.Equal[Object]}
        /if (${Target.Type.Equal[Object]}) {
            /click right target
            /delay 30 ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]} < 50
        }
    }
/return

| ============================================================================
| SUB: Fellowship Recall - Use fellowship recall ability
| ============================================================================
Sub DoFellowshipRecall
    /if (!${FellowshipRecallOn}) /return
    /if (!${Me.Fellowship.Campfire}) /return

    /echo \ay[Fellowship] Using fellowship recall
    /windowstate FellowshipWnd open
    /delay 5
    /notify FellowshipWnd FP_Subwindows tabselect 2
    /delay 5
    /notify FellowshipWnd FP_RefreshList leftmouseup
    /delay 10
    /notify FellowshipWnd FP_CampsiteKitList listselect 1
    /delay 5
    /notify FellowshipWnd FP_CampsiteKitTeleport leftmouseup
    /delay 50
/return

| ============================================================================
| SUB: Check Pet Toys - Request buffs for pet from enchanters
| ============================================================================
Sub CheckPetToys
    /if (!${PetToysOn}) /return
    /if (!${Me.Pet.ID}) /return
    /if (${PetBegActive}) /return

    | Check if pet needs buffs (simplified - check haste)
    /if (!${Me.Pet.Buff[Speed].ID} && !${Me.Pet.Buff[Haste].ID}) {
        /varset PetBegActive 1
        /shout PetToysPlease ${Me.CleanName}
        /delay 50
        /varset PetBegActive 0
    }
/return

| ============================================================================
| SUB: AFK Tools - Auto-reply and AFK management
| ============================================================================
Sub AFKTools
    /if (!${AFKToolsOn}) /return

    | Keep AFK flag set
    /if (!${Me.AFK}) {
        /afk on
    }
/return

| ============================================================================
| SUB: AFK Reply Handler - Reply to tells when AFK
| ============================================================================
Sub Event_AFKTell(string Line, string Teller, string TellMsg)
    /if (!${AFKAutoReply}) /return
    /if (!${AFKToolsOn}) /return

    /tell ${Teller} ${AFKReply}
/return

| ============================================================================
| SUB: Group Watch - Monitor group member status
| ============================================================================
Sub GroupWatch
    /if (!${GroupWatchOn}) /return

    /declare i int local
    /declare MemberID int local

    /for i 0 to ${Group.Members}
        /varset MemberID ${Group.Member[${i}].ID}
        /if (!${MemberID}) /continue

        | Check for dead members
        /if (${GroupWatchAlertDead} && ${Spawn[${MemberID}].Dead}) {
            /if (!${SpamTimer1}) {
                /echo \ar[GroupWatch] ${Group.Member[${i}].CleanName} is DEAD!
                /varset SpamTimer1 100
            }
        }

        | Check for low health
        /if (${Group.Member[${i}].PctHPs} < ${GroupWatchHealPct} && !${Spawn[${MemberID}].Dead}) {
            /if (!${SpamTimer1}) {
                /echo \ay[GroupWatch] ${Group.Member[${i}].CleanName} is at ${Group.Member[${i}].PctHPs}% HP!
                /varset SpamTimer1 50
            }
        }
    /next i
/return

| ============================================================================
| SUB: Hunter Find Mob - Find mob to hunt in Hunter mode
| ============================================================================
Sub HunterFindMob
    /if (!${HunterMode}) /return
    /if (${InCombat}) /return
    /if (${HunterNavPause}) /return

    | Count mobs in area
    /varset MobCount ${SpawnCount[npc targetable radius ${HunterRadius} zradius ${HunterZRadius}]}

    | If not enough mobs, don't hunt
    /if (${MobCount} < ${HunterMinMobs}) {
        /echo \ay[Hunter] Only ${MobCount} mobs - minimum is ${HunterMinMobs}
        /return
    }

    | If too many mobs, don't pull more
    /if (${MobCount} > ${HunterMaxMobs}) {
        /echo \ay[Hunter] ${MobCount} mobs - maximum is ${HunterMaxMobs}
        /return
    }

    | Find nearest mob
    /declare NearestMob int local ${NearestSpawn[npc targetable radius ${HunterRadius} zradius ${HunterZRadius}].ID}

    /if (${NearestMob}) {
        | Nav to the mob
        /if (${UseNav} && ${Navigation.MeshLoaded}) {
            /nav id ${NearestMob}
            /delay 10

            | Wait until we get there or give up
            /declare NavTimer timer local 300
            /while (${Navigation.Active} && ${NavTimer}) {
                /delay 5
                /if (${Spawn[${NearestMob}].Distance} < ${PullRange}) {
                    /nav stop
                    /break
                }
            }
        }

        | Set as pull target
        /varset MyTargetID ${NearestMob}
    }
/return

| ============================================================================
| SUB: Mob Radar - Count mobs and check aggro (XTarget handling)
| ============================================================================
Sub MobRadar(string CheckLOS, int Range, string FromWhere)
    | Count mobs with aggro on us
    /varset XTAggroCount 0
    /varset AggroTargetID 0
    /varset MobCount 0

    /declare i int local
    /declare XTID int local

    | Check extended targets
    /for i 1 to 20
        /varset XTID ${Me.XTarget[${i}].ID}
        /if (${XTID} && ${Me.XTarget[${i}].Type.Equal[Auto Hater]}) {
            /varset XTAggroCount ${Math.Calc[${XTAggroCount}+1]}
            /if (!${AggroTargetID}) {
                /varset AggroTargetID ${XTID}
            }
        }
    /next i

    | Count mobs in range
    /if (${ReturnToCamp} && ${CampXLoc}) {
        /varset MobCount ${SpawnCount[npc targetable loc ${CampXLoc} ${CampYLoc} radius ${Range} zradius ${MaxZRange}]}
    } else {
        /varset MobCount ${SpawnCount[npc targetable radius ${Range} zradius ${MaxZRange}]}
    }
/return

| ============================================================================
| SUB: Check Stuck Gems - Check if casting got stuck
| ============================================================================
Sub CheckStuckGems
    /if (!${CheckStuckGem}) /return
    /if (!${Me.Casting.ID}) /return

    | If we've been casting for too long, interrupt
    /if (${StuckGemTimer} > 150) {
        /echo \ar[StuckGem] Casting appears stuck - interrupting
        /stopcast
        /varset StuckGemTimer 0
    } else {
        /varcalc StuckGemTimer ${StuckGemTimer}+1
    }
/return

| ============================================================================
| SUB: Reset Stuck Gem Timer - Called when cast succeeds
| ============================================================================
Sub ResetStuckGem
    /varset StuckGemTimer 0
/return

| ============================================================================
| SUB: OnExit - Error logging when macro ends
| ============================================================================
:OnExit
    /if (!${MacroQuest.LastCommand.Find[/end]}) {
        | Log error info to INI
        /ini "${IniFileName}" "Error" "LastCommand" "${MacroQuest.LastCommand}"
        /ini "${IniFileName}" "Error" "DateTime" "${Time.Date} ${Time.Time24}"
        /ini "${IniFileName}" "Error" "ErrorMsg" "${MacroQuest.Error}"
        /ini "${IniFileName}" "Error" "DataError" "${MacroQuest.MQ2DataError}"
        /ini "${IniFileName}" "Error" "SyntaxError" "${MacroQuest.SyntaxError}"
        /ini "${IniFileName}" "Error" "RunTime" "${MacroQuest.Running}"
        /ini "${IniFileName}" "Error" "StartTime" "${MacroStartTime}"
        /echo \ar[GronnzMaster] Macro ended unexpectedly - error logged to INI
    }

    | Cleanup
    /if (${XTSlot}) {
        /xtarget set ${XTSlot} autohater
    }
    /if (${Me.Pet.ID} && ${Me.Pet.Stance.NotEqual[follow]}) {
        /pet follow
    }
/return

| ============================================================================
| END OF MACRO
| ============================================================================
